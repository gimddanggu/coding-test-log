# 🧠 문제 이름: [BOJ 3273] 두 수의 합

- 플랫폼: 백준  
- 문제 번호: 3273  
- 난이도: 실버3  
- 링크: [문제 링크](https://www.acmicpc.net/problem/3273)

---

## ⏱ 문제 풀이 기록

- 시작 시간: 20:13  
- 종료 시간: 20:26  
- 총 풀이 시간: 13분 (투 포인터)
    - 10 분 (hash set 방법 시도)

---

## 💭 접근 방법 요약

### 1. 투 포인터 방식

- 수열은 **서로 다른 양의 정수**로 구성되어 있으므로 정렬 후 **양 끝에서 투 포인터** 방식 사용 가능
- `start`와 `end` 포인터를 이용해 두 수의 합을 계산하며, 다음 조건에 따라 포인터를 조정함:
  - 두 수의 합이 `target`보다 작으면 → `start += 1`
  - 두 수의 합이 `target`보다 크면 → `end -= 1`
  - 정확히 일치하면 → `count += 1`, 이후 양쪽 포인터 모두 이동

### 2. HashSet 방식 (초기 접근 → 실패)

- `arr`을 `set`으로 만들어 `in` 연산을 O(1)로 처리하도록 시도
- `for i in range(len(arr) // 2)`까지만 순회하며 `(target - arr[i]) in arr_set`을 체크했으나 ❌ 오답 발생

---

## 🔧 사용한 알고리즘 / 자료구조

- [ ] 구현  
- [x] 정렬  
- [ ] DFS / BFS  
- [x] 투 포인터  
- [ ] 이분 탐색  
- [ ] 누적합  
- [ ] 문자열  
- [ ] 그리디  
- [ ] 완전탐색 / 백트래킹  
- [ ] DP  
- [x] 기타: HashSet

---

## ❗ 어려웠던 점 / 실수

- 투 포인터는 익숙해서 빠르게 해결했지만,  
  HashSet 방식에서 왜 오답이 나오는지 처음엔 명확히 이해하지 못했음
- `len(arr) // 2`까지만 탐색하면 중복을 막을 수 있을 것이라 생각했지만,  
  실제로는 쌍의 한쪽이 리스트 후반에만 존재할 수도 있어 **정답 누락** 발생

---

## ✔ 최종 결과

- [x] 정답 (투 포인터 방식)  
- [ ] 오답  
- [x] 부분 풀이 (HashSet 방식 — 중복 쌍 처리 누락)

---

## 📘 해설 보고 알게 된 점

### 🔹 HashSet 방식이 오답이 된 이유

- 정렬을 해도 HashSet 방식은 탐색 순서를 통제할 수 없기 때문에  
  쌍을 양쪽에서 각각 한 번씩 세게 되어 **중복 카운트** 혹은 **누락**이 발생할 수 있음
- `len(arr) // 2`까지의 탐색은 정렬된 배열에서 중복을 피할 수 있을 것 같지만,
  - 예를 들어 `target = 13`이고, `arr = [1,2,3,4,5,6,7,8,9,10]`이라면
  - `6 + 7 = 13`인데, `6`은 후반부에 있어 탐색이 안 됨 → ❌ 정답 누락
- 따라서 **전체를 순회하며**,  
  `visited` 집합 등을 이용해 중복된 쌍을 방지하는 방식이 필요

### 🔹 중복 쌍 방지 방법 정리

| 방법 | 설명 | 특징 |
|------|------|------|
| 투 포인터 | 인덱스가 겹치지 않도록 조절 | 중복 자연스럽게 방지 |
| visited 집합 | 한 번 센 쌍의 양쪽 수를 기록하여 다시 세지 않음 | HashSet 방식에서 필수 |
| set에서 값 제거 | `arr_set.discard(num)` 방식 | 단, 중복 값이 없을 때만 안전 |

---

## 🔁 복습 기록

- 복습 날짜: 2025-05-02
- HashSet + visited 방식으로 완성 코드 작성 예정
