# 🧠 문제 이름: [BOJ 1920] 수 찾기

- 플랫폼: 백준  
- 문제 번호: 1920  
- 난이도: 실버4  
- 링크: [문제 링크](https://www.acmicpc.net/problem/1920)

---

## ⏱ 문제 풀이 기록

- 시작 시간: 23:02  
- 종료 시간: 23:32  
- 총 풀이 시간: 30분

---

## 💭 접근 방법 요약

- 먼저 기준이 되는 배열 `arr1`과, 존재 여부를 판단할 대상인 `arr2`를 입력받아 분리했다.
- 초기 시도에서는 `for`문과 `in` 연산자를 사용하여 `arr2`의 값이 `arr1`에 존재하는지를 판별했다.
- 하지만 `in` 연산자는 시간복잡도 O(N)이기 때문에 **시간 초과**가 발생했다.
- 이를 해결하기 위해 `arr1`을 정렬한 후 **이진 탐색(binary search)** 방식으로 탐색을 구현했다.
- 이진 탐색 함수는 시작 인덱스, 끝 인덱스, 타겟 값, 배열을 인자로 받으며,
  - 중앙값과 타겟이 같으면 1을 반환
  - 타겟이 더 크면 `start = mid + 1`
  - 타겟이 더 작으면 `end = mid - 1`
  - `start > end`가 되면 탐색 종료 후 0을 반환

---

## 🔧 사용한 알고리즘 / 자료구조

- [ ] 구현  
- [x] 정렬  
- [ ] DFS / BFS  
- [ ] 투 포인터  
- [x] 이분 탐색  
- [ ] 누적합  
- [ ] 문자열  
- [ ] 그리디  
- [ ] 완전탐색 / 백트래킹  
- [ ] DP  
- [ ] 기타: -

---

## ❗ 어려웠던 점 / 실수

- 이진 탐색 함수를 작성할 때 배열을 인자로 넘기지 않고 내부에서 슬라이싱 방식으로 처리해보려 했지만,  
  인덱스 범위 관리가 복잡해져 결국 포기했다.
- `arr1`을 인자로 넘기는 방식이 가장 명확하고 실수도 줄일 수 있다는 것을 깨달았다.
- 목표 시간은 20분이었으나, 직접 구현 실수와 조건 처리 수정 등으로 인해 약 10분 추가 소요됨

---

## ✔ 최종 결과

- [x] 정답  
- [ ] 오답 (시간 내 미완성)  
- [ ] 부분 풀이

---

## 📘 해설 보고 알게 된 점

- 파이썬에는 `bisect` 모듈이 내장되어 있어 이진 탐색을 쉽게 구현할 수 있다.
  - `bisect_left`, `bisect_right` 등을 통해 반복문 없이 탐색이 가능하다.
- 하지만 이번 문제는 이진 탐색 알고리즘을 직접 복습하는 데 의미를 두었고,  
  **기본기를 다지기 위해 직접 구현을 선택했다.**
- 또한, 이 문제는 단순 존재 여부만 판단하면 되므로,
    set() 자료구조를 사용하는 방법도 시간 복잡도 면에서 매우 효율적이다.

    - set은 평균적으로 O(1)의 탐색 속도를 가지기 때문에,
        이 문제에서는 이진 탐색 O(log N)보다도 더 빠르게 동작할 수 있다.
---

## 🔁 복습 기록 (선택)

- 복습 날짜: 2025-04-26  
- 복습 계획:
  - `bisect` 모듈을 사용한 버전도 별도로 구현해보기
  - `set` 자료구조와 비교했을 때 시간 차이 및 메모리 비교하기
