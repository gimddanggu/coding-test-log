# 🧠 문제 이름: [BOJ 11659 - 구간 합 구하기 4]

- 플랫폼: 백준
- 문제 번호: 11659
- 난이도: 실버3
- 링크: [문제 링크](https://www.acmicpc.net/problem/11659)

---

## ⏱ 문제 풀이 기록

- 시작 시간: 22:13
- 종료 시간: 22:37
- 총 풀이 시간: 24분

---

## 💭 접근 방법 요약

- 처음 문제를 봤을 때는 주어진 배열에서 주어진 범위만 슬라이싱하여 `sum()`으로 처리하면 되겠다고 생각했다.  
  → 하지만 이 방식은 매 쿼리마다 O(N) 시간이 들어가므로 **시간 초과**
- 시간 단축을 위해 **누적합 배열(Prefix Sum)** 을 떠올렸다.
- 누적합 배열 `sum_arr`를 만들어 `sum_arr[i] = arr[0] + ... + arr[i-1]` 형태로 구성하고,  
  구간 합은 `sum_arr[j] - sum_arr[i-1]`로 계산하여 **O(1)** 시간에 처리하도록 설계함.
---

## 🔧 사용한 알고리즘 / 자료구조

- [ ] 구현
- [ ] 정렬
- [ ] DFS / BFS
- [ ] 투 포인터
- [ ] 이분 탐색
- [x] 누적합
- [ ] 문자열
- [ ] 그리디
- [ ] 완전탐색 / 백트래킹
- [ ] DP
- [ ] 기타: ______________________

---

## ❗ 어려웠던 점 / 실수

- 누적합 배열을 만들 때 **초기값을 잘못 설정**해서 인덱스가 어긋났고, 이로 인해 범위 계산에 어려움을 겪었다.
- 특히 `[i, j]` 구간의 합을 계산할 때 `sum_arr[j] - sum_arr[i-1]`의 형태를 만들려면,  
  **첫 항 앞에 0을 넣어줘야** 올바른 누적합이 계산된다는 점을 깨달았다.
- 처음에는 첫 항에 바로 `arr[0]`, 두 번째 항에 `arr[0] + arr[1]`을 넣는 방식으로 시작했지만,  
  이 구조에서는 인덱스 연산이 까다로워져 시간이 소요됐다.
---

## ✔ 최종 결과

- [x] 정답
- [ ] 오답 (시간 내 미완성)
- [ ] 부분 풀이

---

## 📘 해설 보고 알게 된 점

- 누적합 배열을 초기값 0으로 시작해 `sum_arr.append(sum_arr[i] + arr[i])` 형태로 구성하면  
  보다 깔끔하고 직관적인 누적합 코드를 만들 수 있다는 점을 배웠다.

---

## 🔁 복습 기록

- 복습 날짜: 2025-04-21
- 복습 내용:
    - 누적합 개념을 확실히 이해하기 위해 직접 구현 한 번 더 해보기