# 🧠 문제 이름: [BOJ 11399] ATM

- 플랫폼: 백준  
- 문제 번호: 11399  
- 난이도: 실버4  
- 링크: [문제 링크](https://www.acmicpc.net/problem/11399)

---

## ⏱ 문제 풀이 기록

- 시작 시간: 20:44  
- 종료 시간: 21:01  
- 총 풀이 시간: 17분

---

## 💭 접근 방법 요약

- 처음엔 이 문제에서 가능한 모든 순열을 고려해야 하는 줄 알았다.
- 하지만 N의 최대값이 1000이라는 점을 보고, **완전탐색(순열)** 방식은 비효율적이라고 판단했다.
- “어떤 순서로 줄을 서는 것이 가장 빠를까?”를 고민하다가,  
  **처리 시간이 짧은 사람을 앞에 세우는 방식이 전체 대기 시간을 줄인다**는 점을 발견했다.
- 그래서 **사람의 인출 시간을 기준으로 정렬**한 뒤,  
  **누적합을 구하는 방식**으로 접근했다.
- 누적합 배열을 만들어 각 사람이 기다리는 시간을 계산하고,  
  이를 모두 더해 최종 대기 시간의 총합을 구했다.

---

## 🔧 사용한 알고리즘 / 자료구조

- [ ] 구현  
- [x] 정렬  
- [ ] DFS / BFS  
- [ ] 투 포인터  
- [ ] 이분 탐색  
- [x] 누적합  
- [ ] 문자열  
- [x] 그리디  
- [ ] 완전탐색 / 백트래킹  
- [ ] DP  
- [ ] 기타: -

---

## ❗ 어려웠던 점 / 실수

- 문제에서 요구하는 조건을 완전히 이해하는 데 시간이 걸렸다.
- 초반에는 문제를 수학적으로 분석하기보다는 예시를 직접 적어보며 해결하려 해서 시간이 조금 소요됐다.
- 하지만 직접 예시를 쓰면서 **"작은 값부터 더해지는 구조가 유리하다"**는 패턴을 발견하게 됐다.

---

## ✔ 최종 결과

- [x] 정답  
- [ ] 오답 (시간 내 미완성)  
- [ ] 부분 풀이

---

## 📘 해설 보고 알게 된 점

- 처음엔 “몇 번째 사람인지”도 중요한 정보일 거라고 생각했지만,  
  사실 이 문제에서는 **인출에 걸리는 시간만이 중요하고, 사람의 순서는 전혀 영향을 주지 않는다**는 점을 깨달았다.
- 또 다른 풀이 방식으로, `for`문과 `sum(nums[:i])`를 통해 누적합 없이도 전체 시간을 구할 수 있다는 것을 알게 되었다.
- `itertools`의 `accumulate()` 함수를 이용하면 **누적합 배열을 간단하게 생성**할 수 있다는 것을 새롭게 배웠다.

---

## 🔁 복습 기록

- 복습 날짜: 2025-04-25  
- 복습 계획:
  - `itertools.accumulate()`를 사용해 누적합을 계산해보는 방식으로 다시 풀어볼 예정
  - 다른 방식(`누적 변수 활용`, `sum(arr[:i])` 방식)도 함께 비교해볼 것

