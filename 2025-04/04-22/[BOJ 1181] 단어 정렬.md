# 🧠 문제 이름: [BOJ 1181] 단어 정렬

- 플랫폼: 백준 
- 문제 번호: 1181
- 난이도: 실버5
- 링크: [문제 링크](https://www.acmicpc.net/problem/1181)

---

## ⏱ 문제 풀이 기록

- 시작 시간: 23:53
- 종료 시간: 00:08
- 총 풀이 시간: 15분

---

## 💭 접근 방법 요약

- 단어 정렬 조건은 다음과 같았다:
  1. 길이가 짧은 순  
  2. 길이가 같다면 사전 순 정렬
- 처음에는 입력받은 단어들을 리스트에 저장하고,  
  `words.sort(key=lambda x: (len(x), x))`로 정렬 조건을 적용했다.
- 그러나 첫 제출에서 오답이 발생했고, 원인을 찾기 위해 문제를 다시 읽어보니  
  **중복된 단어는 제거해야 한다**는 조건을 빠뜨린 것을 발견했다.
- 이를 해결하기 위해 리스트 대신 `set()` 자료형으로 중복을 제거하고,  
  정렬을 위해 `sorted(set)`을 사용했다.

---

## 🔧 사용한 알고리즘 / 자료구조

- [ ] 구현
- [x] 정렬
- [ ] DFS / BFS
- [ ] 투 포인터
- [ ] 이분 탐색
- [ ] 누적합
- [x] 문자열
- [ ] 그리디
- [ ] 완전탐색 / 백트래킹
- [ ] DP
- [ ] 기타: ______________________

---

## ❗ 어려웠던 점 / 실수

- 문제를 제대로 읽지 않고 구현을 시작해, **중복 제거 조건을 놓친 채로 제출**했다.
- 정렬 자체는 정확히 구현했지만, 사소한 조건을 놓쳐 시간이 많이 소요되어 아쉽다.. (10분 컷 가능했는데..)
---

## ✔ 최종 결과

- [x] 정답
- [ ] 오답 (시간 내 미완성)
- [ ] 부분 풀이

---

## 📘 해설 보고 알게 된 점

- 나의 접근은 `lambda`를 이용한 다중 조건 정렬이었고, 올바르게 동작했다.
- 다른 풀이에서는 `sorted()`를 **두 번 나누어 사용**하는 방식이 있었다:
  ```python
  words = sorted(words)              # 1차: 사전 순
  words = sorted(words, key=len)    # 2차: 길이 순
  ```
- 이 방식이 가능한 이유는 파이썬 정렬이 **안정 정렬(stable sort)**이기 때문이다. 
    - → 나중 정렬 기준이 같을 경우, 이전 정렬 순서를 유지하는 것.
---

## 🔁 복습 기록

- 복습 날짜: 2025-04-26
- 정렬 2번 나눠서 해보기