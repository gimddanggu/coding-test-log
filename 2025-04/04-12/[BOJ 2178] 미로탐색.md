# 🧠 문제 이름: [BOJ 2178 - 미로탐색]

- 플랫폼: ( 백준 )
- 문제 번호: 2178
- 난이도: 실버1
- 링크: [문제 링크](https://www.acmicpc.net/problem/2178)

---

## ⏱ 문제 풀이 기록

- 시작 시간: 20:04
- 종료 시간: 20:44
- 총 풀이 시간: 40분

---

## 💭 접근 방법 요약

- **최단경로** 문제이므로 BFS 알고리즘을 선택했다.
- visited 배열은 grid를 0으로 바꾸는 방식으로 처리했지만,  
  해당 위치까지의 거리를 따로 누적해야 한다는 개념은 떠올리지 못했다.


---

## 🔧 사용한 알고리즘 / 자료구조

- [ ] 구현
- [ ] 정렬
- [X] DFS / BFS
- [ ] 투 포인터
- [ ] 이분 탐색
- [ ] 누적합
- [ ] 문자열
- [ ] 그리디
- [ ] 완전탐색 / 백트래킹
- [ ] DP
- [ ] 기타: ______________________

---

## ❗ 어려웠던 점 / 실수

- BFS만 사용하면 최단 거리가 나올 줄 알았지만, 내가 푼 방식은 **모든 갈 수 있는 칸을 순회하는 형태** 였다.
- 최단 거리가 아닌 결과가 나왔다는 건 알았지만, 그 원인을 정확히 파악하지 못했다.
- 거리 누적 방식으로 값을 저장하는 아이디어(`grid[y][x] = grid[prev_y][prev_x] + 1`)를 떠올리지 못해 정답 도출에 실패했다.
---

## ✔ 최종 결과

- [ ] 정답
- [ ] 오답
- [x] 부분 풀이

---

## 📘 해설 보고 알게 된 점

- `grid[ny][nx] = grid[cy][cx] + 1`을 통해, 현재 위치까지의 거리를 누적하면서 다음 위치의 거리값을 계산할 수 있었다.
- 이 방식이라면 도착 좌표인 `grid[n-1][m-1]`의 값이 곧 최단 거리라는 점을 이용해 쉽게 정답을 출력할 수 있다.
- BFS의 특성상 가장 먼저 도달한 경로가 최단 거리이기 때문에, 굳이 `if (x == ...) break` 조건을 사용하지 않아도 정확한 정답이 나온다.

---

## 🔁 복습 기록 (선택)

- 복습 날짜: 2025-04-15
- 거리 누적 방식을 사용해 BFS 구조를 재구현해보기