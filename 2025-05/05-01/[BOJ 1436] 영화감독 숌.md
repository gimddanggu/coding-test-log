# 🧠 문제 이름: [BOJ 1436] 영화감독 숌

- 플랫폼: 백준
- 문제 번호: 1436
- 난이도: 실버 5
- 링크: [문제 링크](https://www.acmicpc.net/problem/1436)

---

## ⏱ 문제 풀이 기록

- 시작 시간: 12:44
- 종료 시간: 14:02
- 총 풀이 시간: 98분

---

## 💭 접근 방법 요약

- 주어진 n 은 10,000 이하의 자연수 이므로, 인덱스를 기준으로 정렬된 번호 리스트 `arr`을 만들어 N번째 수를 출력하려고 했다.
- `666` 이라는 숫자가 포함된 수들을 앞뒤로 숫자를 붙여 생성하며 크기를 비교해 리스트에 추가하려고 했다.
- 규칙을 이용해서 수를 생성하려고 했으나 예외와, 구현이 점점 복잡해졌다.
---

## 🔧 사용한 알고리즘 / 자료구조

- [x] 구현
- [ ] 정렬
- [ ] DFS / BFS
- [ ] 투 포인터
- [ ] 이분 탐색
- [ ] 누적합
- [ ] 문자열
- [ ] 그리디
- [ ] 완전탐색 / 백트래킹
- [ ] DP
- [ ] 기타: ______________________

---

## ❗ 어려웠던 점 / 실수
- 처음 문제 의도를 바로 이해하기 어려웠다
    - 직접 종이에 숫자를 나열해가며 규칙을 찾으려고 했다.
    - 테스트 예제에서 `187 → 66666` 의 결과가 다르게 나옴
    - 5666 → 6660으로 가는 케이스를 생각해 내기까지 오래걸렸다.
- str(i)을 했을 때 0을 str로 변화하니 문자열 0이 추가되는 것이 아니라 빈문자열이 들어왔다. ❌
    - 빈 문자열이 아닌 0으로 제대로 들어왔으나 int(0666) 하는 과정에서 0을 무시한 것.  `print(int(0066)) → 66`


---

## ✔ 최종 결과

- [ ] 정답  
- [x] 오답 (시간 내 미완성)  
- [ ] 부분 풀이

---

## 📘 해설 보고 알게 된 점

- 브루트포스 알고리즘을 사용했다고 하는데 처음 듣는 알고리즘이었다.
    - 브루트포스 알고리즘(brute force)
        - **brute** : 무식한
        - **force** : 힘
        - 즉, 무식한 힘으로 해석할 수 있다!!
        - 완전탐색의 대표적인 방식이며, 가능한 모든 수를 순차적으로 검사하면서 조건을 만족하는 경우만 카운트
        
- 해설을 보니 단순히 `666` 부터 차례로 1씩 더하며 `str(num)` 안에 `666`이 포함되어 있으면, cont를 증가시키고 count가 n이 되면 그 값을 출력하는 방식이었다.. 
- 문제를 풀며 규칙을 찾고자 했는데, 이렇게 간단한 방법이 있을 줄.. 허무하다.. 

---

## 🔁 복습 기록

- 복습 날짜: 2025-05-04
- 추가 학습 계획:
    - 브루트포스 알고리즘 유형의 문제를 더 풀어보며 단순하게 접근하는 연습
    - 문자열 내 포함 여부 ("666" in str(num)) 같은 간단한 조건 활용 숙지하기


## 💡 내 풀이를 본 GPT의 코멘트
1. 규칙 기반 접근은 좋았지만, 이 문제는 오히려 단순하게 접근하는 것이 빠른 유형입니다.

2. 추후 브루트포스 문제에서는 먼저 시간 제한과 입력 범위를 보고 "단순 탐색으로도 되겠다"는 판단을 해보는 습관을 들이면 좋습니다.

3. 또한 문자열 처리와 관련된 실수는 간단한 테스트를 통해 빠르게 확인하는 습관을 들이는 것도 추천합니다.