## 5월 학습내용 회고 및 정리
원래 각 파일 밑에 주석으로 달아 놓은 것을 한번에 정리할 예정 (5.26~)

### 5.26
> [BOJ 11718] 그대로 출력하기

기존에 C++ 입력 방식으로 `cin` 만 생각이 났다
`cin`은 공백을 기준으로 구분한다는 것을 알고 있었지만, 문장을 입력받는 방법을 몰랐다.
처음 코드에서는 `while(ture)`로 반복을 하고 `if(str=="")`이면 반복을 종료하도록 구현하였다.
하지만 공백을 포함한 빈 문자열을 받을 수 없기 때문에 **무한반복 현상**이 나타났다

문장을 입력받기 위해서는 `(1) getline(istream& is, string& str);`, `(2) cin.eof()` 를 사용해야 한다.
- (1) 엔터(개행 문자)를 만날 때 까지 문자열을 받아줌
- (2) Ctrl + D (리눅스) Ctrl + Z(윈도우)로 EOF입력하면 종료

#### ✔ `getline()`
- 운영체제에 따라 입력 줄 끝이 다를 수 있지만, 이를 자동으로 처리하여 줄 끝에서 문자열을 잘라줌.
#### ✔ `cin.eof()`
- EOF 신호는 운영체제에따라 다르지만, 신호가 들어온 후에 true를 반환하므로,
- 운영체제에 상관없이 입력 스트림의 종료 여부를 정확하게 감지할 수 있다.

#### 예시코드
```cpp
while(getline(cin, line))
{
    cout << line << endl;
}

while(cin.eof(line))
{
    getline(file, line);
    cout << line << endl;
}
```



#### [Q.개행문자는 무조건 '\n'??]()
- Unix/Linux/macOS : `\n` (Line Feed)
- Windows : `\r\n` (Carriage Return + Line Feed)
- 고전 Mac(OS9이전) : `\r` (Carriage Return)
- getline()은 내부적으로 줄 끝을 만났을 때

---
> [BOJ 9086] 문자열

문자열의 처음과 끝을 출력하는 문제
인덱스를 이용하여 빠르게 가져오려고 했으나 파이썬 처럼 - 인덱싱이 존재하지 않았다.
`str.size()-1`을 사용해 인덱싱을 하여 문제를 통과했다.
str.begin(), str.end()를 사용하려고 했으나 어떻게 사용하는지 몰랐다.
str.begin()과 str.end()는 자료형으로 string::iterator를 반환하며,
이는 포인터 연산자 `*`를 사용해 실제 값을 참조할 수 있다.

마지막 문자열을 가져오는 다른 방법으로는 str.back() 가 있었다. 

#### Q. 뒤에서 N번째 문자를 출력하고 싶을 때 back(n)을 사용할 수 있나?
- back() 은 파라미터를 받을 수 없다. 
- 따라서 뒤에서 N번째 문자를 가져오기 위해서는 `str.size()-n`을 사용하는 방법과 
- `str.rebegin()`으로 반복자를 가져와 `*(it + n-1)`로 가져오는 방법이 있다.

---
> [BOJ 2475] 검증수


C계열의 함수를 잘 모른다 파이선에는 제곱이 `**`를 사용했다면 C계열은 어떻게 하는지 몰랐다.
문제에서는 `a*a + b*b` 의 방식으로 해결했다.
다른 방법을 찾아봤을 때 `pow(a,2)`함수 이용하는 방법이 있었다. 
`pow()`는 `double`형을 반환하기 때문에 정수 연산에서는 부정확하거나 느릴 수 있다.
```cpp
#include <iostream>
#include <cmath>  // pow 함수
using namespace std;

int main(void)
{
    int a, b, c, d, e;
    cin >> a >> b >> c >> d >> e;

    int result = static_cast<int>(
        pow(a, 2) + pow(b, 2) + pow(c, 2) + pow(d, 2) + pow(e, 2)
    ) % 10;

    cout << result << endl;
    return 0;
}
```

각각의 변수 대신 vector로 입력 받는 방식
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main(void)
{
    vector<int> nums(5);
    int sum = 0;

    for (int i = 0; i < 5; i++) {
        cin >> nums[i];
        sum += nums[i] * nums[i];
    }

    cout << sum % 10 << endl;
    return 0;
}
```

---
> [BOJ 4153] 직각삼각형

숫자 3개를 입력받아 직각삼각형을 판별하는 문제
입력받은 세 개의 정수 중 어떤 값이 최대값인지 알아야 했다.
C++의 함수에 대해 잘 몰라서 인터넷에 벡터의 최대값을 찾는 함수를 찾아보고 문제를 해결하였다.

최대값 찾는 함수 : `max_element(v.begin(), v.end())`
- `#include <algorithm>` 헤더 필요
- 반복자 리턴, `*`연산자로 참조값 얻음

직각삼각형 판별법은 **최대변^2 = 다른 변a^2 + 다른 변b^2** 를 한 값이다.
최대값을 찾은 후 다른 변 제곱 한 값의 합과 비교하여 같으면 'right' 다르면 'wrong` 을 출력한다.

최대값 판별 개선방향 - (1) 정렬 사용

- 오름차순 정렬
- v[0] 이 최대값 
- for 반복문을 돌지않고 `if(v[0]*v[0] + v[1]*v[1] == v[2]*v[2])`만을 사용하여 비교 가능

최대값 판별 개선방향 - (2) 세 값 a, b, c로 분리
  ```cpp
  int m = max({a, b, c})
  sum = a*a + b*b + c*c - m*m
  if (sum == m*m)
  ```
- 정렬없이 가능
- max 값만 뺴고 더하는 안전한 방법

종료조건 개선방향 - 벡터의 합

문제에서는 케이스를 계속해서 입력 받다가 `0 0 0` 입력을 받으면 종료된다.
풀이에서는 `v[0] == 0 && v[1] == 0 && v[2] == 0` 인 조건에서 종료했다.
처음 벡터의 합을 더했을 때 값이 0이면 멈추도록 구현하고 싶었으나 c++에서 벡터의 합을 구하는 방법을 몰랐다 (for문 제외) 
`accumulate()` 함수를 이용해 벡터의 합을 구할 수 있다.
```cpp
#include <numeric>  // accumulate

if (accumulate(v.begin(), v.end(), 0) == 0) break;
```

### 5.27
>**[BOJ 1978] 소수 찾기**

소수는 1과 자기 자신을 제외한 수로는 나누어떨어지지 않는 수를 말한다.  
소수를 판별하는 대표적인 알고리즘으로 **에라토스테네스의 체**가 있다는 것은 알고 있었지만, 
구현 방법이 기억나지 않아 직접 세 가지 방식으로 소수 판별을 구현해보았다.
- [소스코드](./05-27/BOJ%1978.cpp)

**시도한 세 가지 방법**
1. N 범위까지 탐색 ($O(n)$)
2. N /2 범위까지 탐색 ($O(n/2)$)
3. N제곱근 까지 탐색 ($O(\sqrt{n})$)

**코드 개선사항**
GPT에게 내 코드를 보여줬을 때 다음과 같은 사항을 피드백해줬다.
- 불필요한 매개변수 제거
  - 벡터 크기를 나타내는 `a`는 `v.size()`로 대체 가능
  - 소수 개수를 담는 `totalCnt`는 굳이 매개변수로 전달하지 말고, 함수 내 지역 변수로 선언
- 불필요한 벡터 복사 제거
  - `vector<int>`를 값으로 넘기면 전체 벡터가 복사됨 → `const vector<int>&`처럼 **상수 참조**로 전달하는 것이 효율적


처음 `N의 제곱근`까지만 검사하기 위해 `pow(n, 0.5)`를 사용했다. 
제곱근 함수를 사용하고 싶었으나, 내가 아는 함수는 `pow` 뿐이었다.
제곱근 함수 : `sqrt(n)`
하지만 GPT는 이 방법이 정확하지 않을 수 있다고 했다. `pow`나 `sqrt`는 **실수(float)** 연산을 수행하기 때문에, 부동소수점 오차로 인해 조건이 정확하게 평가되지 않을 수 있다는 것이다.

안전하고 효율적인 정수 연산 방식은 다음과 같다:

```cpp
for (int i = 2; i * i <= n; i++)
```

⚔️ 수학연산을 사용할 때에는 `#include<cmath>` 헤더를 넣어주자!

**에라토스테네스의 체**
- 모든 범위의 소수를 찾을 때 유용 
- ex) 50까지의 정수 범위 중 소수는 몇 개인가?


- 알고리즘 설명
    1. 2 ~ 구하고자 하는 구간까지 배열 초기화
    2. 2부터 **자기자신을 제외**한 2의 배수 **모두 제거**
    3. 3도 2.의 과정을 반복
    4. 4는 2번째에서 지워짐, 5의 배수도 같은 방법으로 배수 제거
    5. 구하고자 하는 범위까지 해당 과정 반복
    시간 복잡도 : $O(n \log \log n)$

---

#### 오늘의 회고
python 에서 c++로 언어를 변경했을 때 확실히 알고리즘 측면에서는 문제가 되지 않았다
모르는 알고리즘은 공부하고 구현하면 되니깐..
자료형과 그 언어에 사용되는 함수의 반환형, 매개변수 자료형을 익히는데 시간이 좀 걸릴 거 같다
또한 const 참조를 (`const vector<int>&v`)사용하면 매번 벡터복사가 일어나는 것이 아니라 읽기만 가능 하기 때문에 더 효율적이라는 것을 알았다. 이것 또한 잘 활용해봐야겠다.

### 5.28
> [BOJ 2798] 블랙잭 

[📑소스코드](./05-28/BOJ%2798.cpp) 
이 문제를 처음 보고 3C2 조합 문제라는 사실은 떠올렸지만, 다른 알고리즘이 사용되는 줄 알고 접근했다. 이진 탐색을 이용해 범위를 줄일 수 있지 않을까 고민했고, **정렬** 후 앞에서부터 **차례대로 더하는 방식**으로 로직을 구성했다. 하지만 그렇게 하면 **연속된 조합만 고려**하게 되어, **전체 조합을 탐색하지 못한다는 문제점**이 있었다.

30분 정도 고민한 끝에 GPT에게 힌트를 얻었다. 이 문제의 **입력 조건은 N ≤ 100**으로, 코딩테스트 환경에서는 **1억 번 이하의 연산이 가능**한 만큼 완전탐색 방식으로 2중 또는 3중 반복문을 사용하는 것이 충분하다는 설명이었다. 그 힌트를 바탕으로 **3중 for문**을 사용해 가능한 모든 조합을 탐색하는 방식으로 접근했다.

이 과정에서 또 하나 실수한 부분은 3중 for문의 범위 설정이었다. 이 문제는 **서로 다른 3장을 선택하는 문제이기 때문에, 중복되지 않도록 반복문의 시작 범위를 이전 인덱스 + 1로 설정해야 한다.**
```cpp
for (int i = 0; i < n-2; i++)
{
    for (int j = i+1; j < n-1; j++)
    {
        for (int k = j+1; k < n; k++)
        {

        }
    }
}
```
---

> [BOJ 1259] 팰린드롬수

[📑소스코드](./05-28/BOJ%1259.cpp)

처음에는 문자열의 앞 문자와 끝 문자를 차례로 비교하며, `isPal`이라는 플래그 변수를 사용해 팰린드롬 여부를 판단하도록 구현했다. 서로 다른 문자가 발견되면 `isPal`을 `false`로 설정하고 반복문을 종료한 뒤, 플래그 상태에 따라 `"yes"` 또는 `"no"`를 출력하는 방식이다.

구현 자체는 어렵지 않았지만, `"yes"`와 `"no"`는 문자열임에도 불구하고 작은따옴표(`)를 사용해 출력한 탓에 이상한 결과가 출력되었고, 그 원인을 찾는 데 꽤 시간이 걸렸다. → 이 부분에서 문자와 문자열의 차이를 다시 확인할 수 있었다.

또한 코드에서 보완할 점은, 팰린드롬 검사를 할 때 **문자열의 중앙 문자**는 비교할 필요가 없기 때문에 반복문의 조건을 `i <= nLen / 2`가 아닌 `i < nLen / 2`로 설정하는 것이 더 적절하다.

#### 🔍 문자열 길이 함수
문자열의 길이를 확인할 때는 `str.size()` 또는 `str.length()`를 사용할 수 있으며, 두 함수는 동일하게 null 문자를 제외한 실제 문자열의 길이를 반환한다.

#### 🧪 다른 풀이 - `reverse`를 사용해서 풀기
```cpp
string rev = nStr
reverce(rev.begin(), rev.end());
if (nStr == rev) cout << "yes\n";
else cout << "no\n";
```

#### ⚔️ 참고 - 삼항 연산자, 조건 연산자
`cout << (isPal ? "yes" : "no") << '\n`

#### Q. 문자열 길이 함수는 기능이 완전히 똑같나? 그럼 왜 같은 기능이 2개 있나?
-> ✅ `std::string::size()`와 `std::string::length()`는 기능이 완전히 똑같다.
공식 문서 기준으로 
- 두 함수 모두 `O(1)`의 시간복잡도
- 반환값도 동일: `size_t`

호환성과 직관성을 위해 두 가지 모두 존재
`length()`는 문자열의 길이를 나타내는 데 직관적
`size()`는 STL 컨테이너에서 사용하는 공통 인터페이스이기 때문에 일관성 유지를 위해 제공

---

> [BOJ 1546] 평균

[📑소스코드](./05-28/BOJ%1546.cpp)

전체적으로 어려운 점은 없었다. 
문제에서 **실제 정답과 출력값의 절대오차 또는 상대오차가 10-2 이하이면 정답이다.** 라는 문구가 있어서 소수로 반드시 출력해야되나? 생각했는데 반드시 그런 건 아니었다.

그 과정에서 자료형이 `float` 이면 반드시 소수 포멧으로 출력될 줄 알았는데 아니었다. 소수로 출력하고 싶을 경우 `fixed` 와 `setprecision()`을 사용해야 하는데 `fixed`만 사용하는 경우 반드시 소수포멧으로 출력된다는 보장을 할 수 없다고 한다(컴파일러에 따라 다름) 

또한 소수의 데이터 타입으로 `float`대신 `double`사용을 추천했다. float은 정밀도 ~7자리, double은 ~15자리 이며, 실제 계산에서 **`double` 이 안정적**이라 가능하면 `double`로 통일하여 사용하는게 좋다고 한다. 
+) c++에서는 3.14 같은 리터럴은 기본적으로 `double`로 처리됨
+) float에 소수를 대입할 때는 f를 붙여줘야 안전 `float y = 3.14f;`

---

> [BOJ 2609] 최대공약수와 최소공배수

[📑소스코드](./05-28/BOJ%2609.cpp)
최대공약수를 구하는 대표적인 방법인 **유클리드 호제법**에 대해 알고 있어서, 문제 자체는 큰 어려움 없이 해결할 수 있었다.
다만, 한 가지 실수는 재귀 함수에서 `return`을 붙이지 않아 문제 제출 시 **런타임 에러**가 발생한 것이다.
Visual Studio에서는 정상적으로 실행되었기 때문에 처음에는 원인을 파악하지 못했는데, 이는 **MSVC 컴파일러가 자동으로 처리해줬기 때문**이었다.

✅ **재귀 함수가 어떤 값을 계산해서 바깥으로 전달해야 한다면 반드시 return을 사용해야 한다!**
그렇지 않으면 값이 상위로 전달되지 않아 논리 오류가 발생한다.

#### 코드 개선 사항
1. `if (b > a)` 정렬 로직 → 불필요
유클리드 호제법은 `a < b`인 경우에도 문제없이 작동하므로, 두 수의 크기를 비교해 스왑하는 과정은 생략 가능하다.
처음에는 무조건 큰 수가 앞에 있어야 한다고 생각했는데, 그런 조건이 필요하지 않다는 점을 새롭게 알게 되었다.

2. GCD 함수에서 불필요한 변수 제거
    ```cpp
    if (a % b == 0) return b;
    return GCD(b, a % b);
    ```
나머지를 저장하는 `r` 변수 없이도 간결하게 표현 가능하다.

---

### 5.29

> [BOJ 2775] 부녀회장이 될테야

[📑소스코드](./05-29/BOJ%2775.cpp)

문제를 보고 처음 든 생각은, **아파트 전체 배열을 미리 초기화**해야겠다는 것이었다.
테스트 케이스 개수가 주어졌기 때문에 매번 벡터를 새로 생성할까 고민했지만,
**입력 범위가 14층까지로 고정되어 있으므로 처음 한 번만 초기화하는 방식이 더 효율적**이라 판단했다.

문제에서는 0층부터 시작하여 최대 14층까지 존재하므로,
2차원 벡터에 0층을 먼저 추가한 뒤, 1층부터 14층까지는 반복문을 이용해 값을 누적해나가는 방식으로 초기화하였다.
이때 실수한 부분은 **반복문의 범위를 `j < 14`로 설정**한 것이다.
0층을 이미 추가했기 때문에, 총 15층(0~14층)을 만들기 위해서는 `j <= 14`까지 반복해야 했지만 이를 놓쳤다.

#### 코드 개선 사항
1. **`v1` 재활용 방식 → 새 vector로 대체**
    코드에서는 v1을 외부에 선언하고, v2d.push_back(v1)을 반복적으로 호출하는 방식으로 층을 추가했다.
    이는 **의도치 않은 참조/복사 오류**가 생길 수 있기 때문에, **각 층마다 새로운 `vector<int>`를 생성하는 방식**이 가독성과 안정성 측면에서 더 낫다. 
    
    <br>

2. **중첩 루프 → 누적합 방식으로 최적화**
    기존 방식은 각 층을 계산할 때 0~k까지 반복하여 합산함 → 시간복잡도 `O(N³)`
    하지만 누적합을 이용하면 `O(N)`으로 줄일 수 있다:
    ```cpp
    for (int j = 1; j <= 14; j++)
    {
        vector<int> floor(14);
        for (int k = 0; k < 14; k++)
        {
            if (k == 0) floor[k] = v2d[j-1][k];
            else floor[k] = floor[k-1] + v2d[j-1][k];
        }
        v2d.push_back(floor)
    }
    ```
    **이전 값을 누적**해서 쓰기 때문에 반복 횟수를 대폭 줄일 수 있다.
    
    <br>

3. **매직 넘버 제거 → 의미 있는 상수로 대체**
    문제 조건에 따라 반복문에서 14를 하드코딩했지만,
    나중에 유지보수나 재사용을 고려한다면 `const int MAX = 14;` 같은 상수를 사용하는 것이 더 바람직하다.
        
    <br>

4. **입출력 최적화 (`ios::sync_with_stdio(false);`, `cin.tie(0);`)**

#### Q. `accumulate()` 함수를 문제에 적용할 수 없을까?
accumulate() 함수는 벡터의 구간 합을 구할 수 있는 함수로, 다음과 같은 문법으로 사용한다:
```cpp
accumulate(시작_반복자, 끝_반복자, 초기값);
```
예를 들어, `v[0] ~ v[6]`까지의 합을 구하고 싶다면
`accumulate(v.begin(), v.begin() + 7, 0)`처럼 사용하면 된다.

이처럼 **범위를 지정해 구간합을 구하는 건 가능**하지만, `accumulate()`는 내부적으로 단순한 반복문을 사용하므로 **구간합을 빠르게 계산해주는 자료구조는 아니다.**

따라서 이 문제처럼 반복적으로 누적합을 계산해야 하는 경우에는, **이전 값을 저장하며 누적하는 방식이 성능 면에서 훨씬 효율적**이다.


#### 💡`while (t--)`를 사용해 정해진 횟수만큼 반복할 때 가장 간결한 표현

---

> [BOJ 10989] 수 정렬하기 3

[📑소스코드](./05-29/BOJ%10989.cpp)

처음에 일반적인 `sort()`로 구현하고 **메모리초과** 결과가 나왔다.
**계수정렬**의 방법을 사용하면 시간복잡도가 `O(N)`로 줄일 수 있다는 것을 알고 다시 계수 정렬방법으로 풀어 통과했다.

#### Q. 계수 정렬을 사용할지, 기본 정렬을 사용할지 어떻게 알 수 있을까?
1. 입력 범위(값의 크기) 확인
    - 값의 범위가 작고, 갯수가 많은 경우 (ex. 1 ≤ 값 ≤ 10,000, N ≤ 10⁷)
    - 값의 범위가 크거나 음수 포함/ 실수 ← 기본 정렬 사용
2. 시간 제한과 데이터 수 확인
    - 보통 1초에 1억 연산 가능 
    - `N log N`이 약 5천만 이하면 `sort()`로도 충분히 통과 가능

---

### 5.30

> [BOJ 30802] 웰컴키트

[📑소스코드](./05-30/BOJ%30802.cpp)

문제를 풀이하는데 큰 어려움은 없던 문제였다. 
GPT의 피드백을 받아봤을 때 변수명을 개선하라는 점을 피드백 받았고, 시간복잡도 측면에서는 바꿀 것이 없다고 했다.

---

> [BOJ 2231] 분해합

[📑소스코드](./05-30/BOJ%2231.cpp)

처음엔 분해합의 패턴을 찾으려는 시도를 했다. 각 자리의 합을 더하면 최소 생성자를 유추할 수 있을 거라고 생각했지만, 예제 출력을 확인해보니 **규칙성이 보이지 않았다.**
다음으로는, 분해합이 **"자기 자신 + 각 자리수의 합"**이라는 점을 이용해, 각 자리 수를 하나씩 올려가며 생성자를 찾는 방법을 고민했다. 하지만 **어디서부터 시작해야 할지 기준을 정하기가 어려웠다.**
30분 고민 끝에 힌트를 얻어 문제를 다시 살펴봤고, **1부터 N까지 순차적으로 검사하며 분해합을 구하는 방식**으로 접근하는 것이 가장 확실하다는 것을 깨달았다.

#### 코드 개선 사항
1. `flg` 변수 대신 `return 0`을 사용하면, 마지막에 `if`로 한 번 더 검사하지 않아도 된다. 
→ 생성자를 찾으면 바로 종료하고, 찾지 못하면 `cout << 0;` 한 줄만 실행하게 된다.

2. `sum = 0`으로 시작한 후 `sum + i == n`을 검사하는 방식 대신,
→ `sum = i`로 시작하고 자리수를 더하면 더 깔끔한 코드가 된다.
+ 브루트포스를 더 효율적으로 줄일 수 있는 방법

#### 🔍다른 풀이 분석
```cpp
#include <stdio.h>

// 자릿수 출력 함수
int length(int num) {
	int count = 0;
	for(; num > 0; count++) {
		num /= 10;
	}
	return count;
}

// 자릿수 덧셈
int sum(int num) {
	int value = 0;
	for(; num > 0;) {
		value += num % 10;
		num /= 10;
	} 	
	return value;
}

int main() {
	int m = 0, n;
	scanf("%d", &n);
	int max = length(n) * 9;

	for(int i = max; i > 0; i --) {
		int num = n - i;
		if(num + sum(num) == n) {
			m = num;
			break;
		}
	}
	printf("%d", m);
	return 0;
}
```
위 풀이 방식은 브루트포스를 더 효올적으로 줄이기 위한 방법이다. 
기존 코드는 1부터 n-1 까지 모든 경우를 확인하는 방법이었다면, 위의 코드는 n의 자릿수를 계산해서 분해합이 최대 얼마나 클 수 있는지 계산하는 방법이다.

이 풀이는 브루트포스의 탐색 범위를 줄이는 방식을 사용한다.

기존 방식은 1부터 N-1까지 모든 수를 확인했지만, 이 코드는 **N의 자릿수 × 9를 통해 생성자 후보의 최소 범위를 계산**한 후, `n - max`부터 검사한다는 점이 핵심이다.


**📌 핵심 아이디어**
예를 들어,
`n = 9999`일 때 생성자 후보로 999를 생각해보면,

- 자리수의 합: 9 + 9 + 9 = 27
- 분해합: 999 + 27 = 1026
- 일반화하면: `num + 각 자리수의 합 ≤ num + 9 × 자릿수`

이 식에 따라 분해합이 커질 수 있는 **최댓값은 9 × 자릿수**이므로, 생성자 후보는 **최소 n - (9 × 자릿수)**부터 보면 된다.

이후 복습할 때 최적화 시키는 방법으로 구현해볼 예정이다.
