## 5월 학습내용 회고 및 정리
원래 각 파일 밑에 주석으로 달아 놓은 것을 한번에 정리할 예정 (5.26~)

### 5.26
> [BOJ 11718] 그대로 출력하기

기존에 C++ 입력 방식으로 `cin` 만 생각이 났다
`cin`은 공백을 기준으로 구분한다는 것을 알고 있었지만, 문장을 입력받는 방법을 몰랐다.
처음 코드에서는 `while(ture)`로 반복을 하고 `if(str=="")`이면 반복을 종료하도록 구현하였다.
하지만 공백을 포함한 빈 문자열을 받을 수 없기 때문에 **무한반복 현상**이 나타났다

문장을 입력받기 위해서는 `(1) getline(istream& is, string& str);`, `(2) cin.eof()` 를 사용해야 한다.
- (1) 엔터(개행 문자)를 만날 때 까지 문자열을 받아줌
- (2) Ctrl + D (리눅스) Ctrl + Z(윈도우)로 EOF입력하면 종료

#### ✔ `getline()`
- 운영체제에 따라 입력 줄 끝이 다를 수 있지만, 이를 자동으로 처리하여 줄 끝에서 문자열을 잘라줌.
#### ✔ `cin.eof()`
- EOF 신호는 운영체제에따라 다르지만, 신호가 들어온 후에 true를 반환하므로,
- 운영체제에 상관없이 입력 스트림의 종료 여부를 정확하게 감지할 수 있다.

#### 예시코드
```cpp
while(getline(cin, line))
{
    cout << line << endl;
}

while(cin.eof(line))
{
    getline(file, line);
    cout << line << endl;
}
```



#### [Q.개행문자는 무조건 '\n'??]()
- Unix/Linux/macOS : `\n` (Line Feed)
- Windows : `\r\n` (Carriage Return + Line Feed)
- 고전 Mac(OS9이전) : `\r` (Carriage Return)
- getline()은 내부적으로 줄 끝을 만났을 때

---
> [BOJ 9086] 문자열

문자열의 처음과 끝을 출력하는 문제
인덱스를 이용하여 빠르게 가져오려고 했으나 파이썬 처럼 - 인덱싱이 존재하지 않았다.
`str.size()-1`을 사용해 인덱싱을 하여 문제를 통과했다.
str.begin(), str.end()를 사용하려고 했으나 어떻게 사용하는지 몰랐다.
str.begin()과 str.end()는 자료형으로 string::iterator를 반환하며,
이는 포인터 연산자 `*`를 사용해 실제 값을 참조할 수 있다.

마지막 문자열을 가져오는 다른 방법으로는 str.back() 가 있었다. 

#### Q. 뒤에서 N번째 문자를 출력하고 싶을 때 back(n)을 사용할 수 있나?
- back() 은 파라미터를 받을 수 없다. 
- 따라서 뒤에서 N번째 문자를 가져오기 위해서는 `str.size()-n`을 사용하는 방법과 
- `str.rebegin()`으로 반복자를 가져와 `*(it + n-1)`로 가져오는 방법이 있다.

---
> [BOJ 2475] 검증수


C계열의 함수를 잘 모른다 파이선에는 제곱이 `**`를 사용했다면 C계열은 어떻게 하는지 몰랐다.
문제에서는 `a*a + b*b` 의 방식으로 해결했다.
다른 방법을 찾아봤을 때 `pow(a,2)`함수 이용하는 방법이 있었다. 
`pow()`는 `double`형을 반환하기 때문에 정수 연산에서는 부정확하거나 느릴 수 있다.
```cpp
#include <iostream>
#include <cmath>  // pow 함수
using namespace std;

int main(void)
{
    int a, b, c, d, e;
    cin >> a >> b >> c >> d >> e;

    int result = static_cast<int>(
        pow(a, 2) + pow(b, 2) + pow(c, 2) + pow(d, 2) + pow(e, 2)
    ) % 10;

    cout << result << endl;
    return 0;
}
```

각각의 변수 대신 vector로 입력 받는 방식
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main(void)
{
    vector<int> nums(5);
    int sum = 0;

    for (int i = 0; i < 5; i++) {
        cin >> nums[i];
        sum += nums[i] * nums[i];
    }

    cout << sum % 10 << endl;
    return 0;
}
```

---
> [BOJ 4153] 직각삼각형

숫자 3개를 입력받아 직각삼각형을 판별하는 문제
입력받은 세 개의 정수 중 어떤 값이 최대값인지 알아야 했다.
C++의 함수에 대해 잘 몰라서 인터넷에 벡터의 최대값을 찾는 함수를 찾아보고 문제를 해결하였다.

최대값 찾는 함수 : `max_element(v.begin(), v.end())`
- `#include <algorithm` 헤더 필요
- 반복자 리턴, `*`연산자로 참조값 얻음

직각삼각형 판별법은 **최대변^2 = 다른 변a^2 + 다른 변b^2** 를 한 값이다.
최대값을 찾은 후 다른 변 제곱 한 값의 합과 비교하여 같으면 'right' 다르면 'wrong` 을 출력한다.

최대값 판별 개선방향 - (1) 정렬 사용

- 오름차순 정렬
- v[0] 이 최대값 
- for 반복문을 돌지않고 `if(v[0]*v[0] + v[1]*v[1] == v[2]*v[2])`만을 사용하여 비교 가능

최대값 판별 개선방향 - (2) 세 값 a, b, c로 분리
  ```cpp
  int m = max({a, b, c})
  sum = a*a + b*b + c*c - m*m
  if (sum == m*m)
  ```
- 정렬없이 가능
- max 값만 뺴고 더하는 안전한 방법

종료조건 개선방향 - 벡터의 합

문제에서는 케이스를 계속해서 입력 받다가 `0 0 0` 입력을 받으면 종료된다.
풀이에서는 `v[0] == 0 && v[1] == 0 && v[2] == 0` 인 조건에서 종료했다.
처음 벡터의 합을 더했을 때 값이 0이면 멈추도록 구현하고 싶었으나 c++에서 벡터의 합을 구하는 방법을 몰랐다 (for문 제외) 
`accumulate()` 함수를 이용해 벡터의 합을 구할 수 있다.
```cpp
#include <numeric>  // accumulate

if (accumulate(v.begin(), v.end(), 0) == 0) break;
```