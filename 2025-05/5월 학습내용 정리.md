## 5월 학습내용 회고 및 정리
원래 각 파일 밑에 주석으로 달아 놓은 것을 한번에 정리할 예정 (5.26~)

### 5.26
> [BOJ 11718] 그대로 출력하기

기존에 C++ 입력 방식으로 `cin` 만 생각이 났다
`cin`은 공백을 기준으로 구분한다는 것을 알고 있었지만, 문장을 입력받는 방법을 몰랐다.
처음 코드에서는 `while(ture)`로 반복을 하고 `if(str=="")`이면 반복을 종료하도록 구현하였다.
하지만 공백을 포함한 빈 문자열을 받을 수 없기 때문에 **무한반복 현상**이 나타났다

문장을 입력받기 위해서는 `(1) getline(istream& is, string& str);`, `(2) cin.eof()` 를 사용해야 한다.
- (1) 엔터(개행 문자)를 만날 때 까지 문자열을 받아줌
- (2) Ctrl + D (리눅스) Ctrl + Z(윈도우)로 EOF입력하면 종료

#### ✔ `getline()`
- 운영체제에 따라 입력 줄 끝이 다를 수 있지만, 이를 자동으로 처리하여 줄 끝에서 문자열을 잘라줌.
#### ✔ `cin.eof()`
- EOF 신호는 운영체제에따라 다르지만, 신호가 들어온 후에 true를 반환하므로,
- 운영체제에 상관없이 입력 스트림의 종료 여부를 정확하게 감지할 수 있다.

#### 예시코드
```cpp
while(getline(cin, line))
{
    cout << line << endl;
}

while(cin.eof(line))
{
    getline(file, line);
    cout << line << endl;
}
```



#### [Q.개행문자는 무조건 '\n'??]()
- Unix/Linux/macOS : `\n` (Line Feed)
- Windows : `\r\n` (Carriage Return + Line Feed)
- 고전 Mac(OS9이전) : `\r` (Carriage Return)
- getline()은 내부적으로 줄 끝을 만났을 때

---
> [BOJ 9086] 문자열

문자열의 처음과 끝을 출력하는 문제
인덱스를 이용하여 빠르게 가져오려고 했으나 파이썬 처럼 - 인덱싱이 존재하지 않았다.
`str.size()-1`을 사용해 인덱싱을 하여 문제를 통과했다.
str.begin(), str.end()를 사용하려고 했으나 어떻게 사용하는지 몰랐다.
str.begin()과 str.end()는 자료형으로 string::iterator를 반환하며,
이는 포인터 연산자 `*`를 사용해 실제 값을 참조할 수 있다.

마지막 문자열을 가져오는 다른 방법으로는 str.back() 가 있었다. 

#### Q. 뒤에서 N번째 문자를 출력하고 싶을 때 back(n)을 사용할 수 있나?
- back() 은 파라미터를 받을 수 없다. 
- 따라서 뒤에서 N번째 문자를 가져오기 위해서는 `str.size()-n`을 사용하는 방법과 
- `str.rebegin()`으로 반복자를 가져와 `*(it + n-1)`로 가져오는 방법이 있다.

---
> [BOJ 2475] 검증수


C계열의 함수를 잘 모른다 파이선에는 제곱이 `**`를 사용했다면 C계열은 어떻게 하는지 몰랐다.
문제에서는 `a*a + b*b` 의 방식으로 해결했다.
다른 방법을 찾아봤을 때 `pow(a,2)`함수 이용하는 방법이 있었다. 
`pow()`는 `double`형을 반환하기 때문에 정수 연산에서는 부정확하거나 느릴 수 있다.
```cpp
#include <iostream>
#include <cmath>  // pow 함수
using namespace std;

int main(void)
{
    int a, b, c, d, e;
    cin >> a >> b >> c >> d >> e;

    int result = static_cast<int>(
        pow(a, 2) + pow(b, 2) + pow(c, 2) + pow(d, 2) + pow(e, 2)
    ) % 10;

    cout << result << endl;
    return 0;
}
```

각각의 변수 대신 vector로 입력 받는 방식
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main(void)
{
    vector<int> nums(5);
    int sum = 0;

    for (int i = 0; i < 5; i++) {
        cin >> nums[i];
        sum += nums[i] * nums[i];
    }

    cout << sum % 10 << endl;
    return 0;
}
```

---
> [BOJ 4153] 직각삼각형

숫자 3개를 입력받아 직각삼각형을 판별하는 문제
입력받은 세 개의 정수 중 어떤 값이 최대값인지 알아야 했다.
C++의 함수에 대해 잘 몰라서 인터넷에 벡터의 최대값을 찾는 함수를 찾아보고 문제를 해결하였다.

최대값 찾는 함수 : `max_element(v.begin(), v.end())`
- `#include <algorithm` 헤더 필요
- 반복자 리턴, `*`연산자로 참조값 얻음

직각삼각형 판별법은 **최대변^2 = 다른 변a^2 + 다른 변b^2** 를 한 값이다.
최대값을 찾은 후 다른 변 제곱 한 값의 합과 비교하여 같으면 'right' 다르면 'wrong` 을 출력한다.

최대값 판별 개선방향 - (1) 정렬 사용

- 오름차순 정렬
- v[0] 이 최대값 
- for 반복문을 돌지않고 `if(v[0]*v[0] + v[1]*v[1] == v[2]*v[2])`만을 사용하여 비교 가능

최대값 판별 개선방향 - (2) 세 값 a, b, c로 분리
  ```cpp
  int m = max({a, b, c})
  sum = a*a + b*b + c*c - m*m
  if (sum == m*m)
  ```
- 정렬없이 가능
- max 값만 뺴고 더하는 안전한 방법

종료조건 개선방향 - 벡터의 합

문제에서는 케이스를 계속해서 입력 받다가 `0 0 0` 입력을 받으면 종료된다.
풀이에서는 `v[0] == 0 && v[1] == 0 && v[2] == 0` 인 조건에서 종료했다.
처음 벡터의 합을 더했을 때 값이 0이면 멈추도록 구현하고 싶었으나 c++에서 벡터의 합을 구하는 방법을 몰랐다 (for문 제외) 
`accumulate()` 함수를 이용해 벡터의 합을 구할 수 있다.
```cpp
#include <numeric>  // accumulate

if (accumulate(v.begin(), v.end(), 0) == 0) break;
```

### 5.27
>**[BOJ 1978] 소수 찾기**

소수는 1과 자기 자신을 제외한 수로는 나누어떨어지지 않는 수를 말한다.  
소수를 판별하는 대표적인 알고리즘으로 **에라토스테네스의 체**가 있다는 것은 알고 있었지만, 
구현 방법이 기억나지 않아 직접 세 가지 방식으로 소수 판별을 구현해보았다.
- [소스코드](./05-27/BOJ%1978.cpp)

**시도한 세 가지 방법**
1. N 범위까지 탐색 ($O(n)$)
2. N /2 범위까지 탐색 ($O(n/2)$)
3. N제곱근 까지 탐색 ($O(\sqrt{n})$)

**코드 개선사항**
GPT에게 내 코드를 보여줬을 때 다음과 같은 사항을 피드백해줬다.
- 불필요한 매개변수 제거
  - 벡터 크기를 나타내는 `a`는 `v.size()`로 대체 가능
  - 소수 개수를 담는 `totalCnt`는 굳이 매개변수로 전달하지 말고, 함수 내 지역 변수로 선언
- 불필요한 벡터 복사 제거
  - `vector<int>`를 값으로 넘기면 전체 벡터가 복사됨 → `const vector<int>&`처럼 **상수 참조**로 전달하는 것이 효율적


처음 `N의 제곱근`까지만 검사하기 위해 `pow(n, 0.5)`를 사용했다. 
제곱근 함수를 사용하고 싶었으나, 내가 아는 함수는 `pow` 뿐이었다.
제곱근 함수 : `sqrt(n)`
하지만 GPT는 이 방법이 정확하지 않을 수 있다고 했다. `pow`나 `sqrt`는 **실수(float)** 연산을 수행하기 때문에, 부동소수점 오차로 인해 조건이 정확하게 평가되지 않을 수 있다는 것이다.

안전하고 효율적인 정수 연산 방식은 다음과 같다:

```cpp
for (int i = 2; i * i <= n; i++)
```

⚔️ 수학연산을 사용할 때에는 `#include<cmath>` 헤더를 넣어주자!

**에라토스테네스의 체**
- 모든 범위의 소수를 찾을 때 유용 
- ex) 50까지의 정수 범위 중 소수는 몇 개인가?


- 알고리즘 설명
    1. 2 ~ 구하고자 하는 구간까지 배열 초기화
    2. 2부터 **자기자신을 제외**한 2의 배수 **모두 제거**
    3. 3도 2.의 과정을 반복
    4. 4는 2번째에서 지워짐, 5의 배수도 같은 방법으로 배수 제거
    5. 구하고자 하는 범위까지 해당 과정 반복
    시간 복잡도 : $O(n \log \log n)$

---

#### 오늘의 회고
python 에서 c++로 언어를 변경했을 때 확실히 알고리즘 측면에서는 문제가 되지 않았다
모르는 알고리즘은 공부하고 구현하면 되니깐..
자료형과 그 언어에 사용되는 함수의 반환형, 매개변수 자료형을 익히는데 시간이 좀 걸릴 거 같다
또한 const 참조를 (`const vector<int>&v`)사용하면 매번 벡터복사가 일어나는 것이 아니라 읽기만 가능 하기 때문에 더 효율적이라는 것을 알았다. 이것 또한 잘 활용해봐야겠다.
