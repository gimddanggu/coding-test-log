## 5월 학습내용 회고 및 정리
원래 각 파일 밑에 주석으로 달아 놓은 것을 한번에 정리할 예정 (5.26~)

### 5.26
> [BOJ 11718] 그대로 출력하기

기존에 C++ 입력 방식으로 `cin` 만 생각이 났다
`cin`은 공백을 기준으로 구분한다는 것을 알고 있었지만, 문장을 입력받는 방법을 몰랐다.
처음 코드에서는 `while(ture)`로 반복을 하고 `if(str=="")`이면 반복을 종료하도록 구현하였다.
하지만 공백을 포함한 빈 문자열을 받을 수 없기 때문에 **무한반복 현상**이 나타났다

문장을 입력받기 위해서는 `(1) getline(istream& is, string& str);`, `(2) cin.eof()` 를 사용해야 한다.
- (1) 엔터(개행 문자)를 만날 때 까지 문자열을 받아줌
- (2) Ctrl + D (리눅스) Ctrl + Z(윈도우)로 EOF입력하면 종료

#### ✔ `getline()`
- 운영체제에 따라 입력 줄 끝이 다를 수 있지만, 이를 자동으로 처리하여 줄 끝에서 문자열을 잘라줌.
#### ✔ `cin.eof()`
- EOF 신호는 운영체제에따라 다르지만, 신호가 들어온 후에 true를 반환하므로,
- 운영체제에 상관없이 입력 스트림의 종료 여부를 정확하게 감지할 수 있다.

#### 예시코드
```cpp
while(getline(cin, line))
{
    cout << line << endl;
}

while(cin.eof(line))
{
    getline(file, line);
    cout << line << endl;
}
```



#### [Q.개행문자는 무조건 '\n'??]()
- Unix/Linux/macOS : `\n` (Line Feed)
- Windows : `\r\n` (Carriage Return + Line Feed)
- 고전 Mac(OS9이전) : `\r` (Carriage Return)
- getline()은 내부적으로 줄 끝을 만났을 때

---
> [BOJ 9086] 문자열

문자열의 처음과 끝을 출력하는 문제
인덱스를 이용하여 빠르게 가져오려고 했으나 파이썬 처럼 - 인덱싱이 존재하지 않았다.
`str.size()-1`을 사용해 인덱싱을 하여 문제를 통과했다.
str.begin(), str.end()를 사용하려고 했으나 어떻게 사용하는지 몰랐다.
str.begin()과 str.end()는 자료형으로 string::iterator를 반환하며,
이는 포인터 연산자 `*`를 사용해 실제 값을 참조할 수 있다.

마지막 문자열을 가져오는 다른 방법으로는 str.back() 가 있었다. 

#### Q. 뒤에서 N번째 문자를 출력하고 싶을 때 back(n)을 사용할 수 있나?
- back() 은 파라미터를 받을 수 없다. 
- 따라서 뒤에서 N번째 문자를 가져오기 위해서는 `str.size()-n`을 사용하는 방법과 
- `str.rebegin()`으로 반복자를 가져와 `*(it + n-1)`로 가져오는 방법이 있다.

---
> [BOJ 2475] 검증수


C계열의 함수를 잘 모른다 파이선에는 제곱이 `**`를 사용했다면 C계열은 어떻게 하는지 몰랐다.
문제에서는 `a*a + b*b` 의 방식으로 해결했다.
다른 방법을 찾아봤을 때 `pow(a,2)`함수 이용하는 방법이 있었다. 
`pow()`는 `double`형을 반환하기 때문에 정수 연산에서는 부정확하거나 느릴 수 있다.
```cpp
#include <iostream>
#include <cmath>  // pow 함수
using namespace std;

int main(void)
{
    int a, b, c, d, e;
    cin >> a >> b >> c >> d >> e;

    int result = static_cast<int>(
        pow(a, 2) + pow(b, 2) + pow(c, 2) + pow(d, 2) + pow(e, 2)
    ) % 10;

    cout << result << endl;
    return 0;
}
```

각각의 변수 대신 vector로 입력 받는 방식
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main(void)
{
    vector<int> nums(5);
    int sum = 0;

    for (int i = 0; i < 5; i++) {
        cin >> nums[i];
        sum += nums[i] * nums[i];
    }

    cout << sum % 10 << endl;
    return 0;
}
```

---
> [BOJ 4153] 직각삼각형

숫자 3개를 입력받아 직각삼각형을 판별하는 문제
입력받은 세 개의 정수 중 어떤 값이 최대값인지 알아야 했다.
C++의 함수에 대해 잘 몰라서 인터넷에 벡터의 최대값을 찾는 함수를 찾아보고 문제를 해결하였다.

최대값 찾는 함수 : `max_element(v.begin(), v.end())`
- `#include <algorithm` 헤더 필요
- 반복자 리턴, `*`연산자로 참조값 얻음

직각삼각형 판별법은 **최대변^2 = 다른 변a^2 + 다른 변b^2** 를 한 값이다.
최대값을 찾은 후 다른 변 제곱 한 값의 합과 비교하여 같으면 'right' 다르면 'wrong` 을 출력한다.

최대값 판별 개선방향 - (1) 정렬 사용

- 오름차순 정렬
- v[0] 이 최대값 
- for 반복문을 돌지않고 `if(v[0]*v[0] + v[1]*v[1] == v[2]*v[2])`만을 사용하여 비교 가능

최대값 판별 개선방향 - (2) 세 값 a, b, c로 분리
  ```cpp
  int m = max({a, b, c})
  sum = a*a + b*b + c*c - m*m
  if (sum == m*m)
  ```
- 정렬없이 가능
- max 값만 뺴고 더하는 안전한 방법

종료조건 개선방향 - 벡터의 합

문제에서는 케이스를 계속해서 입력 받다가 `0 0 0` 입력을 받으면 종료된다.
풀이에서는 `v[0] == 0 && v[1] == 0 && v[2] == 0` 인 조건에서 종료했다.
처음 벡터의 합을 더했을 때 값이 0이면 멈추도록 구현하고 싶었으나 c++에서 벡터의 합을 구하는 방법을 몰랐다 (for문 제외) 
`accumulate()` 함수를 이용해 벡터의 합을 구할 수 있다.
```cpp
#include <numeric>  // accumulate

if (accumulate(v.begin(), v.end(), 0) == 0) break;
```

### 5.27
>**[BOJ 1978] 소수 찾기**

소수는 1과 자기 자신을 제외한 수로는 나누어떨어지지 않는 수를 말한다.  
소수를 판별하는 대표적인 알고리즘으로 **에라토스테네스의 체**가 있다는 것은 알고 있었지만, 
구현 방법이 기억나지 않아 직접 세 가지 방식으로 소수 판별을 구현해보았다.
- [소스코드](./05-27/BOJ%1978.cpp)

**시도한 세 가지 방법**
1. N 범위까지 탐색 ($O(n)$)
2. N /2 범위까지 탐색 ($O(n/2)$)
3. N제곱근 까지 탐색 ($O(\sqrt{n})$)

**코드 개선사항**
GPT에게 내 코드를 보여줬을 때 다음과 같은 사항을 피드백해줬다.
- 불필요한 매개변수 제거
  - 벡터 크기를 나타내는 `a`는 `v.size()`로 대체 가능
  - 소수 개수를 담는 `totalCnt`는 굳이 매개변수로 전달하지 말고, 함수 내 지역 변수로 선언
- 불필요한 벡터 복사 제거
  - `vector<int>`를 값으로 넘기면 전체 벡터가 복사됨 → `const vector<int>&`처럼 **상수 참조**로 전달하는 것이 효율적


처음 `N의 제곱근`까지만 검사하기 위해 `pow(n, 0.5)`를 사용했다. 
제곱근 함수를 사용하고 싶었으나, 내가 아는 함수는 `pow` 뿐이었다.
제곱근 함수 : `sqrt(n)`
하지만 GPT는 이 방법이 정확하지 않을 수 있다고 했다. `pow`나 `sqrt`는 **실수(float)** 연산을 수행하기 때문에, 부동소수점 오차로 인해 조건이 정확하게 평가되지 않을 수 있다는 것이다.

안전하고 효율적인 정수 연산 방식은 다음과 같다:

```cpp
for (int i = 2; i * i <= n; i++)
```

⚔️ 수학연산을 사용할 때에는 `#include<cmath>` 헤더를 넣어주자!

**에라토스테네스의 체**
- 모든 범위의 소수를 찾을 때 유용 
- ex) 50까지의 정수 범위 중 소수는 몇 개인가?


- 알고리즘 설명
    1. 2 ~ 구하고자 하는 구간까지 배열 초기화
    2. 2부터 **자기자신을 제외**한 2의 배수 **모두 제거**
    3. 3도 2.의 과정을 반복
    4. 4는 2번째에서 지워짐, 5의 배수도 같은 방법으로 배수 제거
    5. 구하고자 하는 범위까지 해당 과정 반복
    시간 복잡도 : $O(n \log \log n)$

---

#### 오늘의 회고
python 에서 c++로 언어를 변경했을 때 확실히 알고리즘 측면에서는 문제가 되지 않았다
모르는 알고리즘은 공부하고 구현하면 되니깐..
자료형과 그 언어에 사용되는 함수의 반환형, 매개변수 자료형을 익히는데 시간이 좀 걸릴 거 같다
또한 const 참조를 (`const vector<int>&v`)사용하면 매번 벡터복사가 일어나는 것이 아니라 읽기만 가능 하기 때문에 더 효율적이라는 것을 알았다. 이것 또한 잘 활용해봐야겠다.

### 5.28
> [BOJ 2798] 블랙잭 

[📑소스코드](./05-28/BOJ%2798.cpp) 
이 문제를 처음 보고 3C2 조합 문제라는 사실은 떠올렸지만, 다른 알고리즘이 사용되는 줄 알고 접근했다. 이진 탐색을 이용해 범위를 줄일 수 있지 않을까 고민했고, **정렬** 후 앞에서부터 **차례대로 더하는 방식**으로 로직을 구성했다. 하지만 그렇게 하면 **연속된 조합만 고려**하게 되어, **전체 조합을 탐색하지 못한다는 문제점**이 있었다.

30분 정도 고민한 끝에 GPT에게 힌트를 얻었다. 이 문제의 **입력 조건은 N ≤ 100**으로, 코딩테스트 환경에서는 **1억 번 이하의 연산이 가능**한 만큼 완전탐색 방식으로 2중 또는 3중 반복문을 사용하는 것이 충분하다는 설명이었다. 그 힌트를 바탕으로 **3중 for문**을 사용해 가능한 모든 조합을 탐색하는 방식으로 접근했다.

이 과정에서 또 하나 실수한 부분은 3중 for문의 범위 설정이었다. 이 문제는 **서로 다른 3장을 선택하는 문제이기 때문에, 중복되지 않도록 반복문의 시작 범위를 이전 인덱스 + 1로 설정해야 한다.**
```cpp
for (int i = 0; i < n-2; i++)
{
    for (int j = i+1; j < n-1; j++)
    {
        for (int k = j+1; k < n; k++)
        {

        }
    }
}
```
---

> [BOJ 1259] 팰린드롬수

[📑소스코드](./05-28/BOJ%1259.cpp)

처음에는 문자열의 앞 문자와 끝 문자를 차례로 비교하며, `isPal`이라는 플래그 변수를 사용해 팰린드롬 여부를 판단하도록 구현했다. 서로 다른 문자가 발견되면 `isPal`을 `false`로 설정하고 반복문을 종료한 뒤, 플래그 상태에 따라 `"yes"` 또는 `"no"`를 출력하는 방식이다.

구현 자체는 어렵지 않았지만, `"yes"`와 `"no"`는 문자열임에도 불구하고 작은따옴표(`)를 사용해 출력한 탓에 이상한 결과가 출력되었고, 그 원인을 찾는 데 꽤 시간이 걸렸다. → 이 부분에서 문자와 문자열의 차이를 다시 확인할 수 있었다.

또한 코드에서 보완할 점은, 팰린드롬 검사를 할 때 **문자열의 중앙 문자**는 비교할 필요가 없기 때문에 반복문의 조건을 `i <= nLen / 2`가 아닌 `i < nLen / 2`로 설정하는 것이 더 적절하다.

#### 🔍 문자열 길이 함수
문자열의 길이를 확인할 때는 `str.size()` 또는 `str.length()`를 사용할 수 있으며, 두 함수는 동일하게 null 문자를 제외한 실제 문자열의 길이를 반환한다.

#### 🧪 다른 풀이 - `reverse`를 사용해서 풀기
```cpp
string rev = nStr
reverce(rev.begin(), rev.end());
if (nStr == rev) cout << "yes\n";
else cout << "no\n";
```

#### ⚔️ 참고 - 삼항 연산자, 조건 연산자
`cout << (isPal ? "yes" : "no") << '\n`

#### Q. 문자열 길이 함수는 기능이 완전히 똑같나? 그럼 왜 같은 기능이 2개 있나?
-> ✅ `std::string::size()`와 `std::string::length()`는 기능이 완전히 똑같다.
공식 문서 기준으로 
- 두 함수 모두 `O(1)`의 시간복잡도
- 반환값도 동일: `size_t`

호환성과 직관성을 위해 두 가지 모두 존재
`length()`는 문자열의 길이를 나타내는 데 직관적
`size()`는 STL 컨테이너에서 사용하는 공통 인터페이스이기 때문에 일관성 유지를 위해 제공

---

> [BOJ 1546] 평균

[📑소스코드](./05-28/BOJ%1546.cpp)

전체적으로 어려운 점은 없었다. 
문제에서 **실제 정답과 출력값의 절대오차 또는 상대오차가 10-2 이하이면 정답이다.** 라는 문구가 있어서 소수로 반드시 출력해야되나? 생각했는데 반드시 그런 건 아니었다.

그 과정에서 자료형이 `float` 이면 반드시 소수 포멧으로 출력될 줄 알았는데 아니었다. 소수로 출력하고 싶을 경우 `fixed` 와 `setprecision()`을 사용해야 하는데 `fixed`만 사용하는 경우 반드시 소수포멧으로 출력된다는 보장을 할 수 없다고 한다(컴파일러에 따라 다름) 

또한 소수의 데이터 타입으로 `float`대신 `double`사용을 추천했다. float은 정밀도 ~7자리, double은 ~15자리 이며, 실제 계산에서 **`double` 이 안정적**이라 가능하면 `double`로 통일하여 사용하는게 좋다고 한다. 
+) c++에서는 3.14 같은 리터럴은 기본적으로 `double`로 처리됨
+) float에 소수를 대입할 때는 f를 붙여줘야 안전 `float y = 3.14f;`

---

> [BOJ 2609] 최대공약수와 최소공배수

[📑소스코드](./05-28/BOJ%2609.cpp)
최대공약수를 구하는 대표적인 방법인 **유클리드 호제법**에 대해 알고 있어서, 문제 자체는 큰 어려움 없이 해결할 수 있었다.
다만, 한 가지 실수는 재귀 함수에서 `return`을 붙이지 않아 문제 제출 시 **런타임 에러**가 발생한 것이다.
Visual Studio에서는 정상적으로 실행되었기 때문에 처음에는 원인을 파악하지 못했는데, 이는 **MSVC 컴파일러가 자동으로 처리해줬기 때문**이었다.

✅ **재귀 함수가 어떤 값을 계산해서 바깥으로 전달해야 한다면 반드시 return을 사용해야 한다!**
그렇지 않으면 값이 상위로 전달되지 않아 논리 오류가 발생한다.

#### 코드 개선 사항
1. `if (b > a)` 정렬 로직 → 불필요
유클리드 호제법은 `a < b`인 경우에도 문제없이 작동하므로, 두 수의 크기를 비교해 스왑하는 과정은 생략 가능하다.
처음에는 무조건 큰 수가 앞에 있어야 한다고 생각했는데, 그런 조건이 필요하지 않다는 점을 새롭게 알게 되었다.

2. GCD 함수에서 불필요한 변수 제거
    ```cpp
    if (a % b == 0) return b;
    return GCD(b, a % b);
    ```
나머지를 저장하는 `r` 변수 없이도 간결하게 표현 가능하다.
---