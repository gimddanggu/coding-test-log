# 6월 학습내용 회고 및 정리

## 06.04 (수)
> [BOJ 2292] 벌집

문제를 보고 주어진 조건을 바탕으로 벌집 구조를 직접 그려보았다.
각 층의 방 개수는 6의 배수씩 증가하며, 다음과 같은 규칙을 발견할 수 있었다:
- 1층: 시작 1, 끝 1
- 2층: 시작 2, 끝 7
- 3층: 시작 8, 끝 19
- ...

이 규칙을 기반으로 각 층의 시작 번호만을 벡터에 저장하고, 입력된 N이 어느 층에 포함되는지 탐색하는 방식으로 문제를 해결했다.
주의해야 할 점은, 주어진 입력 범위가 `1 ≤ N ≤ 1,000,000,000` 이었기 때문에, 벡터를 충분히 크게 생성해야 했다.
처음에는 `start <= 1,000,000,000`까지만 반복했지만, 이 경우 **N이 딱 끝 값에 해당될 때 출력을 하지 못하는 예외**가 발생했다.
따라서 반복 조건을 `start <= 1,001,000,000` 정도로 임의로 조금 더 크게 설정하여 모든 테스트 케이스를 통과시킬 수 있었다.

### 다른 풀이
다른 사람들의 코드를 참고했을 때, 벡터 없이 **풀 수 있는 방식**이 더 간단하고 효율적이라는 것을 알게 되었다.
대부분의 풀이에서는 각 층의 **끝 번호를 기준**으로 비교하여 입력된 N이 속하는 층을 구한다.

```cpp
int layer = 1;
int Maxnum = 1;

while (maxnum < N )
{
    maxnum += (6 * layer);
    layer++;
    cout << Maxnum << '\n';
}
```
- `N`의 크기에 따라 필요한 만큼만 반복하며, 메모리를 낭비하지 않는다.
- 시작값이 아니라 끝값 기준으로 비교하기 때문에 **경계 조건에서도 오류 없이 안정적으로 동작**한다.

---

> [BOJ 15829] Hashing

이 문제는 주어진 수식을 그대로 구현하는 간단한 문제였다.
처음 제출한 코드에서는 50점을 받았는데, 그 이유는 다음과 같다:

$$
H = \left( \sum_{i=0}^{l-1} a_i r^i \right) \bmod M
$$

위 수식에서 거듭제곱 계산을 위해 `pow(r, i)`를 사용했는데, 이 함수는 `double`형을 반환한다.
이로 인해 **정수 연산에서 오차가 발생하거나, 지수가 커질수록 오버플로우 가능성**이 생긴다.

따라서 `pow(r, i)` 대신` power = (power * r) % M` 방식으로 직접 누적 곱을 계산하는 것이 정확하다.

또한 처음에는 전체 합을 구한 후 마지막에 `mod M`을 적용했는데,
이 또한 **중간 계산에서 오버플로우가 발생**할 수 있으므로, 아래와 같은 모듈러의 성질을 이용해 매 단계마다 나머지 연산을 수행하는 것이 바람직하다:
$$(a⋅b) mod m=((a mod m)⋅(b mod m))
$$ 수학적으로 결과가 동일하다


➤ 🧠 **누적 합 또는 누적 곱을 계산할 때는 반드시 중간마다 `mod` 연산을 해주는 것이 안전**하다.

#### **알파벳 인덱스**
알파벳 인덱스를 계산할 때 `str[i] - 96` 방식보다 `str[i] - 'a' + 1` 방식이
**가독성과 의도를 명확히 전달**하는 데 더 좋다.

---

> [BOJ 2869] 달팽이는 올라가고 싶다

문제를 처음 보고는 조건도 제대로 확인하지 않은 채 `while()` 반복문으로 구현했다. 하지만 결과는 시간초과였다.

총 이동해야 하는 거리 `v`를 하루 동안 실제로 올라가는 거리 `(a - b)`로 나누면 될 것 같았지만,
**"정상에서는 미끄러지지 않는다"**는 조건을 어떻게 반영할지 몰라서 꽤 오랫동안 헤매게 되었다.
약 40분 정도 고민하다가 결국 GPT에게 수식 유도를 물어봤고, 다음과 같은 설명을 들었다.

**🔍 핵심 아이디어**
정상에 도달하는 날은 밤에 미끄러지지 않기 때문에,
`v`에서 밤에 미끄러질 거리 `b`를 뺀 뒤, 하루 실제 이동량 `(a - b)`로 나누는 수식을 사용해야 한다고 했다.
$\displaystyle \text{day} = \frac{v - a}{a - b} + 1$
➤ 정수 나눗셈만으로 표현하기 위해 아래처럼 바꿈:

$\displaystyle \text{day} = \left\lceil \frac{v - b}{a - b} \right\rceil$

```cpp
int day = (v - b - 1) / (a - b) + 1;
```





#### Q.`-a`를 해주는 게 더 직관적이지 않나?
처음에는 `a`를 빼야 한다고 생각했다.
하지만 `a`를 빼고 나면, 이후 남은 거리에 대해 다시 시뮬레이션을 반복해야 하는 번거로움이 생긴다.
반면 `b`를 빼면, **도착한 날엔 미끄러지지 않는다**는 조건을 깔끔하게 반영할 수 있다.

즉, 전체 목표 거리에서 **마지막 날 미끄러지는 구간을 미리 제외**한 후
**정수 나눗셈을 통해 올림 계산을 해주는 방식이 더 깔끔하고 효율적**이다.

#### 💡 수학 함수
| 함수    | 설명                 |
| ----- | ------------------ |
| floor | 내림                 |
| round | 반올림                |
| ceil  | 올림 (소수점 있으면 무조건 ↑) |

코드에서는 `ceil()` 함수를 직접 쓰지 않고, 정수로 올림을 구현하는 방식인
`(v - b - 1) / (a - b) + 1`을 사용해 **빠르고 정확한 연산**이 가능하도록 했다.
