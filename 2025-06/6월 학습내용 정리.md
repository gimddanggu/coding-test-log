# 6월 학습내용 회고 및 정리

## 06.04 (수)
### [BOJ 2292] 벌집
> [🔗[BOJ 2292] 벌집](https://www.acmicpc.net/problem/2292)
  [📑소스코드](./06-04/BOJ%2292.cpp)


문제를 보고 주어진 조건을 바탕으로 벌집 구조를 직접 그려보았다.
각 층의 방 개수는 6의 배수씩 증가하며, 다음과 같은 규칙을 발견할 수 있었다:
- 1층: 시작 1, 끝 1
- 2층: 시작 2, 끝 7
- 3층: 시작 8, 끝 19
- ...

이 규칙을 기반으로 각 층의 시작 번호만을 벡터에 저장하고, 입력된 N이 어느 층에 포함되는지 탐색하는 방식으로 문제를 해결했다.
주의해야 할 점은, 주어진 입력 범위가 `1 ≤ N ≤ 1,000,000,000` 이었기 때문에, 벡터를 충분히 크게 생성해야 했다.
처음에는 `start <= 1,000,000,000`까지만 반복했지만, 이 경우 **N이 딱 끝 값에 해당될 때 출력을 하지 못하는 예외**가 발생했다.
따라서 반복 조건을 `start <= 1,001,000,000` 정도로 임의로 조금 더 크게 설정하여 모든 테스트 케이스를 통과시킬 수 있었다.

### 다른 풀이
다른 사람들의 코드를 참고했을 때, 벡터 없이 **풀 수 있는 방식**이 더 간단하고 효율적이라는 것을 알게 되었다.
대부분의 풀이에서는 각 층의 **끝 번호를 기준**으로 비교하여 입력된 N이 속하는 층을 구한다.

```cpp
int layer = 1;
int Maxnum = 1;

while (maxnum < N )
{
    maxnum += (6 * layer);
    layer++;
    cout << Maxnum << '\n';
}
```
- `N`의 크기에 따라 필요한 만큼만 반복하며, 메모리를 낭비하지 않는다.
- 시작값이 아니라 끝값 기준으로 비교하기 때문에 **경계 조건에서도 오류 없이 안정적으로 동작**한다.

---

### [BOJ 15829] Hashing

> [🔗[BOJ 15829] Hashing](https://www.acmicpc.net/problem/15829)
> [📑소스코드](./06-04/BOJ%15829.cpp)

이 문제는 주어진 수식을 그대로 구현하는 간단한 문제였다.
처음 제출한 코드에서는 50점을 받았는데, 그 이유는 다음과 같다:

$$
H = \left( \sum_{i=0}^{l-1} a_i r^i \right) \bmod M
$$

위 수식에서 거듭제곱 계산을 위해 `pow(r, i)`를 사용했는데, 이 함수는 `double`형을 반환한다.
이로 인해 **정수 연산에서 오차가 발생하거나, 지수가 커질수록 오버플로우 가능성**이 생긴다.

따라서 `pow(r, i)` 대신` power = (power * r) % M` 방식으로 직접 누적 곱을 계산하는 것이 정확하다.

또한 처음에는 전체 합을 구한 후 마지막에 `mod M`을 적용했는데,
이 또한 **중간 계산에서 오버플로우가 발생**할 수 있으므로, 아래와 같은 모듈러의 성질을 이용해 매 단계마다 나머지 연산을 수행하는 것이 바람직하다:
$$ (a⋅b) mod m=((a mod m)⋅(b mod m)) $$ 
수학적으로 결과가 동일하다


➤ 🧠 **누적 합 또는 누적 곱을 계산할 때는 반드시 중간마다 `mod` 연산을 해주는 것이 안전**하다.

#### **알파벳 인덱스**
알파벳 인덱스를 계산할 때 `str[i] - 96` 방식보다 `str[i] - 'a' + 1` 방식이
**가독성과 의도를 명확히 전달**하는 데 더 좋다.

---

### [BOJ 2869] 달팽이는 올라가고 싶다

> [🔗[BOJ 2869] 달팽이는 올라가고 싶다](https://www.acmicpc.net/problem/2869)
> [📑소스코드](./06-04/BOJ%2869.cpp)

문제를 처음 보고는 조건도 제대로 확인하지 않은 채 `while()` 반복문으로 구현했다. 하지만 결과는 시간초과였다.

총 이동해야 하는 거리 `v`를 하루 동안 실제로 올라가는 거리 `(a - b)`로 나누면 될 것 같았지만,
**"정상에서는 미끄러지지 않는다"**는 조건을 어떻게 반영할지 몰라서 꽤 오랫동안 헤매게 되었다.
약 40분 정도 고민하다가 결국 GPT에게 수식 유도를 물어봤고, 다음과 같은 설명을 들었다.

#### 🔍 핵심 아이디어
정상에 도달하는 날은 밤에 미끄러지지 않기 때문에,
`v`에서 밤에 미끄러질 거리 `b`를 뺀 뒤, 하루 실제 이동량 `(a - b)`로 나누는 수식을 사용해야 한다고 했다.
$\displaystyle \text{day} = \frac{v - a}{a - b} + 1$
➤ 정수 나눗셈만으로 표현하기 위해 아래처럼 바꿈:

$\displaystyle \text{day} = \left\lceil \frac{v - b}{a - b} \right\rceil$

```cpp
int day = (v - b - 1) / (a - b) + 1;
```





#### Q.`-a`를 해주는 게 더 직관적이지 않나?
처음에는 `a`를 빼야 한다고 생각했다.
하지만 `a`를 빼고 나면, 이후 남은 거리에 대해 다시 시뮬레이션을 반복해야 하는 번거로움이 생긴다.
반면 `b`를 빼면, **도착한 날엔 미끄러지지 않는다**는 조건을 깔끔하게 반영할 수 있다.

즉, 전체 목표 거리에서 **마지막 날 미끄러지는 구간을 미리 제외**한 후
**정수 나눗셈을 통해 올림 계산을 해주는 방식이 더 깔끔하고 효율적**이다.

#### 💡 수학 함수
| 함수    | 설명                 |
| ----- | ------------------ |
| floor | 내림                 |
| round | 반올림                |
| ceil  | 올림 (소수점 있으면 무조건 ↑) |

코드에서는 `ceil()` 함수를 직접 쓰지 않고, 정수로 올림을 구현하는 방식인
`(v - b - 1) / (a - b) + 1`을 사용해 **빠르고 정확한 연산**이 가능하도록 했다.

## 06.05 (목)

### [BOJ 7568] 덩치

> [🔗[BOJ 7568] 덩치](https://www.acmicpc.net/problem/7568)
  [📑소스코드](./06-05/BOJ%7568.cpp)

이 문제는 키와 몸무게가 주어졌을 때, 사람 간의 덩치를 비교하여 덩치 순위를 매기는 문제이다.
처음에는 **정렬**을 활용하여 해결하고자 했다. 몸무게와 키를 기준으로 정렬한 뒤, 몸무게 순서가 정해졌으니 **키를 기준으로 등수를 판단하면 된다고 생각**했다.

하지만 몇 개의 테스트 케이스에서는 정답이 잘 나오다가도, 결국 **오답** 판정을 받았다.

이유를 생각해보니, 덩치 순위를 매기는 기준은 단순 정렬이 아니라 다음과 같았다:

- **자신보다 덩치가 큰 사람 수 + 1 = 자신의 순위**
- 여기서 "덩치가 크다"는 조건은 몸무게와 키가 모두 클 때만 성립한다.

정렬을 활용한 방식의 문제점은, **선형 순서를 강제**하기 때문에
→ 정렬된 순서에서 **자신의 위에 있는 사람들만 가지고 판단**하게 된다는 점이다.
→ 결국, **자신보다 뒤에 있지만 실제로 덩치가 더 큰 사람**을 등수 계산에서 놓치게 된다.

#### 해결방법 - 브루트포스 알고리즘
가장 직관적이고 정확한 방법은 **브루트포스 알고리즘**이다.
→ **모든 사람과 쌍 비교(pairwise)** 를 하면서,
→ 키와 몸무게 모두 큰 사람이 있을 경우 `rank++`
→ 그렇지 않으면 `rank` 유지

정렬 기반 접근보다 **더 직관적이고 깔끔**하다.
그리고 이 문제의 입력 크기`(N ≤ 50)`를 고려할 때, 시간복잡도 부담도 없다.

#### Q. 언제 정렬을 쓰고 언제 완전탐색을 써야할까??

**정렬이 잘 통하는 문제 유형**
| 문제 유형                            | 설명                                 | 예시                                             |
| -------------------------------- | ---------------------------------- | ---------------------------------------------- |
| **1️⃣ 우열 관계가 단일 기준이거나 선형 비교가 가능할 때** | 하나의 기준으로만 비교 가능 (ex: 점수, 날짜, 거리 등) | 📌 `회의실 배정`, `수 정렬하기`, `최솟값/최댓값 문제` |
| **2️⃣ 정렬 후 그리디하게 처리 가능한 구조**         | 정렬된 상태에서 왼쪽→오른쪽 순회하며 해를 결정 가능      | 📌 `ATM 인출 시간 합계`, `보석 도둑`         |
| **3️⃣ 우선순위 큐로도 해결 가능한 문제**           | 값의 크기에 따라 우선순위가 완전히 정해지는 경우        | 📌 `절댓값 힙`, `최소 힙`, `강의실 배정`                   |
| **4️⃣ 좌표 압축, 이벤트 정렬 문제**             | 특정 시점/좌표 기반 정렬 후 스캔라인 형태로 해결       | 📌 `겹치는 선분`, `라인 스위핑`, `구간 합`                  |

**정렬이 잘 안통하는 문제 유형**
| 문제 유형                      | 설명                                       | 예시                                           |
| -------------------------- | ---------------------------------------- | -------------------------------------------- |
| **1️⃣ 부분 순서(Partial Order)**   | 두 값이 크다/작다 관계가 **명확하지 않은 경우**            | 📌 `덩치`, `키 순서 관계 정하기`, `부분 순열 비교` |
| **2️⃣ 쌍 비교(pairwise)가 본질인 문제** | 모든 요소 간 관계를 따져야 해서 정렬로 우열 정하기 어려움        | 📌 `지배 관계`, `N명 중 진짜 최고 찾기` |
| **3️⃣ 정렬이 부정확한 기준을 만들어버리는 경우** | ex: `몸무게 내림차순 + 키 오름차순` 같이 두 기준이 엇갈리는 경우 | 📌 `덩치`   |
| **4️⃣ 구현 또는 시뮬레이션 문제**         | 요구사항 그대로 구현해야 하므로 정렬은 영향 없음              | 📌 `로봇 청소기`, `톱니바퀴`, `뱀 게임`  |


➤ 🧠 정렬은 선형 우열 관계가 명확할 때!!
**조건이 A > B인지 불분명한 경우(부분 순서)** 에는 쌍 비교 or 그래프 탐색 시도!!!

#### 💡`pair` 사용법
- `pair` : **두 개의 값을 한 쌍으로 묶어서 저장할 수 있는** STL 자료구조
- `first`, `second` 멤버를 통해 각각의 값에 접근

**선언 및 초기화**
```cpp
pair<int, int> p;
p.first = 100;
p.second = 180;

pair<int, string> p2 = make_pair(1, "hi"); // 또는 {1, "hi"}
```
**벡터와 함께 사용**
```cpp
vector<pair<int, int>>
v.push_back({100, 180});
v.push_back({90, 190});
cout << v[0].first << " " << v[0].second << '\n';  // 100 180 출력
```

**정렬 기준**
기본 정렬 : `first` 오름차순 -> `second` 오름차순
pair는 비교 연산자(`<`, `>`, `==`, `!=`, ...)가 자동 정의되어 있음
```cpp
// 2번째 값 기준으로 정렬
sort(v.begin(), v.end(), [](pair<int, int>& a, pair<int, int>& b) {
    return a.second > b.second;  // second 기준 내림차순
});
```
**구조 분해(C++17 이상)**
```cpp
pair<int, string> p = {1, "hi"};
auto [num, text] = p;

cout << num << " " << text;  // 1 hi

// 위의 코드는 아래와 동일하게 동작
int num = p.first;
string text = p.second;
```
- 참조 바인딩을 하려면 `auto& [a, b] = p;` 또는 `const auto&` 사용


### [BOJ 11651] 좌표 정렬하기 2

> [🔗[BOJ 11651] 좌표 정렬하기 2](https://www.acmicpc.net/problem/11651)
  [📑소스코드](./06-05/BOJ%11651.cpp)

이 문제는 **2차원 좌표쌍을 주어진 기준에 맞게 정렬할 수 있는지를 묻는 문제**다.
앞서 학습한 정렬 관련 지식을 기반으로 수월하게 해결할 수 있었다.

이 문제에서 좌표쌍이 주어졌기 때문에 `vector<pair<int, int>>` 자료구조를 사용했다.
문제 조건이 **1. y기준으로 정렬** **2. x 기준으로 정렬하는 것**, 즉 정렬 기준이 두 개 이므로 람다함수를 이용하여 구현했다. 

#### **람다식 이용한 정렬**
```cpp
[](매개변수1, 매개변수2) {
    if (조건)
        return ...;
    return ...;
}
```
람다 대신 별도의 비교 함수를 선언해서 `sort()`의 세 번째 인자로 넘겨도 동일한 결과를 얻을 수 있다.

#### 다른 풀이
```cpp
pair<int, int> p[100001];
for (int i = 0; i < n; i++) {
    cin >> p[i].second >> p[i].first;
}
sort(p, p + n);
```
이 풀이는 배열과 기본 정렬 기준을 잘 활용한 C 스타일 풀이다.
`pair`의 기본 정렬 기준이 `first → second`이기 때문에,
입력 시 `second`를 y로, `first`를 x로 받아 **자동 정렬 효과**를 얻었다.

`sort(p, p + n)`에서 p는 배열이므로, `p`는 시작 주소이고 `p + n`은 끝 주소를 의미한다.
```CPP
p      == &p[0]         // 시작 주소
p + n  == &p[n]         // 끝 주소 (1칸 뒤)
```
→ STL 컨테이너의 `v.begin(), v.end()`와 같은 의미다.

## 06.06 ~ 06.18 
리눅스 시험 및 컨디션 이슈로 휴식

## 06.19(목)
### [BOJ 1018] 체스판 다시 칠하기

> [🔗[BOJ 1018] 체스판 다시 칠하기](https://www.acmicpc.net/problem/1018)
  [📑소스코드](./06-19/BOJ%201018.cpp)

이 문제는 N×M 크기의 체스판이 주어지고,
이 중에서 **8×8 크기의 체스판을 선택해** 정답 체스판으로 만들기 위해
다시 칠해야 하는 최소 칸 수를 구하는 문제이다.

처음 이 문제를 접했을 때, 나는 기준 좌표를 중심으로 4방향 색상이 달라야 한다고 생각해서 DFS 방식으로 해결해보려 했다.
그러나 `visited` 벡터를 따로 관리해야 하고,
색을 바꾼 뒤 다시 돌아와야 하는 등 구현이 복잡하다는 점에서 반복문 방식으로 방향을 전환했다.

그런데 내가 처음 구현한 반복문 방식에도 치명적인 문제점이 있었다.
**체스판의 시작 좌표가 항상 맞다고 가정하고 로직을 작성한 것**이다.
이 방식은 입력으로 주어진 체스판을 정답으로 신뢰하고,
거기에 맞춰 색을 바꾸는 방식이 되기 때문에
**이미 틀린 입력에 대해서도 정답처럼 판단하게 되어 오답이 발생한다.**

#### 핵심 로직
아래와 같이 체스판의 패턴이 번갈하 칠해져야 할 경우를 생각해보면
```cpp
0: B W B W B W ...
1: W B W B W B ...
2: B W B W B W ...
```
입력받은 체스판의 시작점을 기준으로,
해당 칸이 `B`로 시작하는 경우, 또는 `W`로 시작하는 경우
두 가지 경우 모두를 검사한 뒤, **더 적게 칠해도 되는 쪽**을 선택해야 한다.

#### 핵심 코드
```CPP

for (int i = sy; i < sy + 8; i++)
{
    for (int j = sx; j < sx + 8; j++)
    {
        bool answer1 = ((i + y) % 2 == 0) ? board[sy][sx] : !board[sy][sx];
        bool answer2 = !answer1;

        bool curColor = board[i][j];

        if (curColor != answer1) count1++;
        if (curColor != answer2) count2++;

        answer1 = !answer1;
        answer2 = !answer2;
    }
}
```
이와 같은 방식은 주어진 입력을 신뢰하지 않고, **체스판의 규칙 자체를 수학적으로 모델링**하여 정확히 어떤 칸이 어떤 색이어야 하는지를 판단하게 해준다.
이를 통해 행과 열에 따라 자연스럽게 색이 번갈아야 하는 체스판 패턴을 정확히 재현할 수 있다.
 
---

## 06.22(일)
### [BOJ 10816] 숫자 카드 2

> [🔗 문제 링크](https://www.acmicpc.net/problem/10816)  
  [📑 소스코드](./06-22/BOJ_10816.cpp)

---

#### 문제 접근

처음 이 문제를 접했을 때 **이진 탐색을 이용해 풀어야겠다**고 생각했다.  
Python에서는 `bisect` 라이브러리를 자주 사용했지만, C++ STL에는 익숙하지 않아 직접 이진 탐색을 구현하기로 했다.



#### 첫 시도: 직접 이진 탐색 구현 -> 실패

- 정렬된 배열에서 원하는 수를 찾은 뒤, 해당 인덱스를 기준으로 **양옆으로 같은 값을 세는 방식**으로 구현
- 그러나 **중복된 값 중 아무 위치나 찾기 때문에**, 찾은 위치가 반드시 처음 등장한 인덱스는 아님
- 이를 보완하기 위해 **좌/우로 선형 탐색을 추가**했지만, 결국 시간 초과 발생

> [처음 구현한 코드](./06-22/BOJ_10816_직접구현.cpp)



#### 시간 복잡도 분석

- 정렬: `O(N log N)`
- 각 쿼리마다:
  - 이진 탐색: `O(log N)`
  - 좌/우 선형 탐색: `O(K)` (중복된 수의 개수)
- 총 시간 복잡도: `M × (O(log N) + O(K))` → 최악의 경우 `O(M × N)`
→ `N, M ≤ 500,000` 이므로 **최악의 경우 연산량이 25억**을 초과하여 시간 초과 발생



#### STL `lower_bound` / `upper_bound` 사용 -> 문제 해결결

- `lower_bound`: 찾는 값 이상이 처음 나오는 위치
- `upper_bound`: 찾는 값 초과가 처음 나오는 위치

→ 두 위치의 차이 `(upper - lower)`가 곧 해당 수의 **개수**

```cpp
int l = lower_bound(card1.begin(), card1.end(), num) - card1.begin();
int r = upper_bound(card1.begin(), card1.end(), num) - card1.begin();
cout << r - l;
```